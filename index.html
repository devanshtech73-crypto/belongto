<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Canvas 2D Drift (Standard API Only)</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #111; 
            touch-action: none; user-select: none; font-family: 'Arial', sans-serif;
        }
        #gameCanvas { display: block; width: 100vw; height: 100vh; }
        
        /* The UI remains the same */
        #ui-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; z-index: 100;
        }
        #dashboard {
            position: absolute; top: env(safe-area-inset-top, 10px); left: 10px;
            color: white; padding: 10px 15px; background: rgba(0, 0, 0, 0.4); 
            backdrop-filter: blur(5px); border-radius: 8px; pointer-events: none;
            text-align: right; border-left: 3px solid #ff0077;
        }
        #speedometer { font-size: 24px; font-weight: bold; }
        #drift-meter { font-size: 16px; color: #ff0077; }
        #controls {
            position: absolute; bottom: env(safe-area-inset-bottom, 20px); left: 0; right: 0;
            height: 150px; display: flex; justify-content: space-between; padding: 0 10px;
        }
        .control-btn {
            width: 100px; height: 100px; border-radius: 50%; margin: 20px 10px;
            display: flex; align-items: center; justify-content: center; font-size: 30px;
            font-weight: bold; color: white; pointer-events: auto; transition: all 0.1s;
            background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 255, 255, 0.5); box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .control-group { display: flex; flex-direction: column; justify-content: flex-end; gap: 10px; }
        .control-btn:active { background: rgba(255, 255, 255, 0.5); transform: scale(0.9); box-shadow: 0 0 20px #ff0077; }
        #handbrake { background: rgba(255, 0, 0, 0.3); border-color: rgba(255, 0, 0, 0.7); }
        #handbrake:active { box-shadow: 0 0 20px #ff0000; }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<canvas id="skidCanvas" style="display:none;"></canvas> <div id="ui-overlay">
    <div id="dashboard">
        <div>SPEED: <span id="speedometer">0</span> KPH</div>
        <div>SLIP: <span id="drift-meter">0.0</span></div>
    </div>

    <div id="controls">
        <div class="control-group">
            <div class="control-btn" id="steer-left">◄</div>
            <div class="control-btn" id="steer-right">►</div>
        </div>
        
        <div class="control-group right-controls">
            <div class="control-btn" id="handbrake" style="height: 60px; width: 100px; border-radius: 15px;">HB</div>
            <div style="display: flex; gap: 10px;">
                <div class="control-btn" id="brake">B</div>
                <div class="control-btn" id="accelerate">A</div>
            </div>
        </div>
    </div>
</div>

<script>
// --- CANVAS & CONTEXT SETUP ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const skidCanvas = document.getElementById('skidCanvas');
const skidCtx = skidCanvas.getContext('2d');

let WIDTH, HEIGHT;

function resizeCanvas() {
    WIDTH = canvas.width = window.innerWidth;
    HEIGHT = canvas.height = window.innerHeight;
    skidCanvas.width = WIDTH * 3; // Make skid canvas large to cover map area
    skidCanvas.height = HEIGHT * 3;
    skidCtx.fillStyle = 'rgba(0, 0, 0, 0)'; // Transparent background
    skidCtx.fillRect(0, 0, skidCanvas.width, skidCanvas.height);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();


// --- UI ELEMENTS ---
const ui = {
    speed: document.getElementById('speedometer'),
    drift: document.getElementById('drift-meter'),
    taillights: document.getElementById('brake'), // Using the brake button for event signaling
};


// --- INPUT STATE ---
const input = {
    accelerate: false, brake: false, handbrake: false, steer: 0, throttle: 0,
};

// --- CAR PHYSICS CONFIGURATION (Same as previous, tuned for realism) ---
const carConfig = {
    mass: 1200, halfWidth: 1.0, halfHeight: 2.5,
    engineForce: 20000, brakeForce: 25000, handbrakeGripFactor: 0.1,
    gripForward: 4.0, gripLateral: 6.0,
    maxSteerAngle: Math.PI / 6, steerSpeed: 0.05,
    pixelScale: 25, // Pixels per Meter (for drawing)
};

// --- GAME OBJECTS & VARIABLES ---
let car = {
    x: 0, y: 0, angle: 0, 
    velocity: { x: 0, y: 0 },
    angularVelocity: 0,
    steerAngle: 0, 
    bodyRoll: 0,
    color: '#0055AA'
};

let camera = {
    x: 0, y: 0, 
    followSpeed: 0.1 
};

// --- INPUT HANDLERS (Same as previous) ---
function setupTouchControls() {
    const controls = {
        'accelerate': 'accelerate', 'brake': 'brake', 'handbrake': 'handbrake',
        'steer-left': 'steerLeft', 'steer-right': 'steerRight',
    };

    for (const id in controls) {
        const element = document.getElementById(id);
        const action = controls[id];

        const touchStart = (e) => {
            e.preventDefault();
            if (action === 'steerLeft') input.steer = -1;
            else if (action === 'steerRight') input.steer = 1;
            else input[action] = true;
        };

        const touchEnd = (e) => {
            e.preventDefault();
            if (action === 'steerLeft' || action === 'steerRight') input.steer = 0;
            else input[action] = false;
        };

        element.addEventListener('touchstart', touchStart, { passive: false });
        element.addEventListener('touchend', touchEnd, { passive: false });
        element.addEventListener('touchcancel', touchEnd, { passive: false });

        if (id === 'brake') {
            element.addEventListener('touchstart', () => ui.taillights.style.boxShadow = '0 0 20px 5px #FF5555');
            element.addEventListener('touchend', () => ui.taillights.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5)');
        }
    }
}


// --- PHYSICS ENGINE (Simplified for Canvas) ---

function updateCarPhysics(delta) {
    const config = carConfig;
    const dt = delta / 60; 

    // 1. INPUT HANDLING
    input.throttle = input.accelerate ? 1 : 0;
    car.steerAngle += (input.steer * config.maxSteerAngle - car.steerAngle) * config.steerSpeed * dt * 50;

    // 2. FORCE CALCULATIONS
    const angleRad = car.angle;
    const forwardVector = { x: Math.cos(angleRad), y: Math.sin(angleRad) };
    const rightVector = { x: Math.cos(angleRad + Math.PI / 2), y: Math.sin(angleRad + Math.PI / 2) };
    
    let forwardV = car.velocity.x * forwardVector.x + car.velocity.y * forwardVector.y;
    let rightV = car.velocity.x * rightVector.x + car.velocity.y * rightVector.y;
    let totalForce = { x: 0, y: 0 };
    
    // Engine/Brake Force
    let engineForce = input.throttle * config.engineForce;
    totalForce.x += forwardVector.x * engineForce;
    totalForce.y += forwardVector.y * engineForce;
    
    let brakeForce = input.brake ? config.brakeForce : 0;
    if (brakeForce > 0) {
        totalForce.x -= forwardVector.x * brakeForce * Math.sign(forwardV);
        totalForce.y -= forwardVector.y * brakeForce * Math.sign(forwardV);
    }

    // Lateral Friction (Drift Physics Core)
    let lateralGrip = config.gripLateral;
    if (input.handbrake) lateralGrip *= config.handbrakeGripFactor; 
    
    totalForce.x -= rightVector.x * rightV * lateralGrip * config.mass;
    totalForce.y -= rightVector.y * rightV * lateralGrip * config.mass;

    // Rolling Resistance
    totalForce.x -= forwardVector.x * forwardV * config.gripForward * config.mass;
    totalForce.y -= forwardVector.y * forwardV * config.gripForward * config.mass;
    
    // 3. MOTION INTEGRATION
    car.velocity.x += totalForce.x / config.mass * dt;
    car.velocity.y += totalForce.y / config.mass * dt;
    car.x += car.velocity.x * dt;
    car.y += car.velocity.y * dt;
    
    // Angular Motion
    const speedMagnitude = Math.sqrt(car.velocity.x**2 + car.velocity.y**2);
    let driftAngle = Math.atan2(rightV, forwardV) * 0.5;
    let yawTorque = forwardV * car.steerAngle * 0.15;
    yawTorque -= car.angularVelocity * 1.5; 
    yawTorque -= driftAngle * forwardV * config.gripLateral * 0.05; 
    car.angularVelocity += yawTorque * dt;
    car.angle += car.angularVelocity * dt;
    car.angularVelocity *= 0.98;
    
    // 4. SKID MARKS & DRIFT DETECTION
    const velocityAngle = Math.atan2(car.velocity.y, car.velocity.x);
    let slipAngle = Math.abs(car.angle - velocityAngle);
    if (slipAngle > Math.PI) slipAngle -= 2 * Math.PI;
    slipAngle = Math.abs(slipAngle);
    
    const driftIntensity = slipAngle * speedMagnitude;
    
    if (driftIntensity > 5 && speedMagnitude > 20) {
        drawSkidMark(car.x, car.y, car.angle, config.halfHeight, config.pixelScale);
    }
    
    // 5. VISUAL BODY ROLL EFFECT
    car.bodyRoll += (rightV * 0.01 - car.bodyRoll) * 0.1;
    car.bodyRoll = Math.max(-1, Math.min(1, car.bodyRoll));

    // Update UI
    const kph = Math.floor(speedMagnitude * 3.6);
    ui.speed.innerText = kph;
    ui.drift.innerText = slipAngle.toFixed(2);
}

// --- DRAWING FUNCTIONS (Standard 2D Canvas) ---

// Draw the persistent skid mark texture onto the hidden canvas
function drawSkidMark(x, y, angle, halfHeight, scale) {
    const globalX = x * scale + skidCanvas.width/2;
    const globalY = y * scale + skidCanvas.height/2;

    const offsetX = Math.cos(angle + Math.PI) * halfHeight * scale;
    const offsetY = Math.sin(angle + Math.PI) * halfHeight * scale;
    
    skidCtx.save();
    skidCtx.translate(globalX + offsetX, globalY + offsetY);
    skidCtx.rotate(angle + Math.PI/2);

    skidCtx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // Dark semi-transparent
    skidCtx.fillRect(-5, -5, 10, 10); // Simple skid stamp

    skidCtx.restore();
}

// Draw the Road and Environment
function drawEnvironment(ctx, camX, camY, scale) {
    // 1. Background (Green/Off-road)
    ctx.fillStyle = '#4CAF50'; 
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    
    // 2. Road (Dark Asphalt)
    ctx.save();
    ctx.translate(WIDTH/2 - camX * scale, HEIGHT/2 - camY * scale);
    
    // Simulating infinite asphalt with repeating colors/gradients
    const asphaltGradient = ctx.createLinearGradient(0, 0, 0, HEIGHT * 2);
    asphaltGradient.addColorStop(0, '#333333');
    asphaltGradient.addColorStop(0.5, '#444444');
    asphaltGradient.addColorStop(1, '#333333');
    
    ctx.fillStyle = asphaltGradient;
    ctx.fillRect(-WIDTH, -HEIGHT, WIDTH * 2, HEIGHT * 2);
    
    // 3. Skid Mark Layer (Paste the hidden canvas)
    // Calculate the offset to position the skid marks correctly relative to the camera
    const skidOffsetX = camX * scale - skidCanvas.width / 2;
    const skidOffsetY = camY * scale - skidCanvas.height / 2;
    
    ctx.globalAlpha = 0.8;
    ctx.drawImage(skidCanvas, -skidOffsetX, -skidOffsetY);
    ctx.globalAlpha = 1.0;

    // 4. Road Markings (Simple dashed lines)
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.lineWidth = 4;
    ctx.setLineDash([40, 40]);
    ctx.beginPath();
    ctx.moveTo(0, -HEIGHT * 2);
    ctx.lineTo(0, HEIGHT * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    
    ctx.restore();
}

// Draw the Car with Shading and Lights
function drawCar(ctx, car, scale) {
    ctx.save();
    
    // 1. Translate to Car's position (in screen space)
    ctx.translate(WIDTH/2, HEIGHT/2);
    
    // 2. Rotate and Skew (for body roll effect)
    ctx.rotate(car.angle + Math.PI/2);
    ctx.transform(1, 0, car.bodyRoll * 0.5, 1, 0, 0); // Apply skew/roll

    const w = carConfig.halfWidth * scale * 2;
    const h = carConfig.halfHeight * scale * 2;
    
    // 3. Draw Body (with gradient for simple shading/realism)
    const bodyGradient = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
    bodyGradient.addColorStop(0, car.color);
    bodyGradient.addColorStop(1, '#AAAAAA'); // Suggests highlight/reflection

    ctx.fillStyle = bodyGradient;
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.roundRect(-w/2, -h/2, w, h, 8);
    ctx.fill();
    ctx.stroke();

    // 4. Lights
    const lightSize = w * 0.1;

    // Headlights (Front) - Soft white glow
    ctx.fillStyle = '#FFFFFF';
    ctx.shadowColor = '#FFFFFF';
    ctx.shadowBlur = 10;
    ctx.globalAlpha = 0.8;
    ctx.fillRect(w/2 - lightSize, -h/2 + lightSize, lightSize, lightSize/2);
    ctx.fillRect(w/2 - lightSize, h/2 - lightSize, lightSize, lightSize/2);
    
    // Tail Lights (Rear) - Red glow, brighter when braking
    ctx.fillStyle = input.brake ? '#FF4444' : '#AA0000';
    ctx.shadowColor = input.brake ? '#FF4444' : '#AA0000';
    ctx.shadowBlur = input.brake ? 15 : 5;
    ctx.globalAlpha = 1.0;
    ctx.fillRect(-w/2, -h/2 + lightSize, lightSize/2, lightSize/2);
    ctx.fillRect(-w/2, h/2 - lightSize, lightSize/2, lightSize/2);

    ctx.shadowBlur = 0; // Reset shadow for next draw

    // 5. Roof/Windshield (simple black)
    ctx.fillStyle = '#333333';
    ctx.fillRect(-w/4, -h/4, w/2, h/2);

    ctx.restore();
}

// --- MAIN GAME LOOP ---

function update(time) {
    requestAnimationFrame(update);
    
    // Clear the main canvas
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    
    // Calculate delta time (for framerate independence, though simple delta used here)
    const delta = 1; 

    // 1. Physics Update
    updateCarPhysics(delta);

    // 2. Camera Update (Smooth Follow)
    camera.x += (car.x - camera.x) * camera.followSpeed * delta;
    camera.y += (car.y - camera.y) * camera.followSpeed * delta;
    
    // 3. Draw Environment and Skids (Uses World space coordinates)
    drawEnvironment(ctx, camera.x, camera.y, carConfig.pixelScale);
    
    // 4. Draw Car (Uses Screen center coordinates)
    drawCar(ctx, car, carConfig.pixelScale);
}

// Start the game
setupTouchControls();
update(0); // Start the animation loop
</script>
</body>
</html>
