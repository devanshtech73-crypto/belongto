<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Top-Down Driving Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
    :root {
        --hud-font: 14px Arial, sans-serif;
    }
    * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
    }
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #1b1b1b;
        touch-action: none;
    }
    body {
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
        max-width: 100vw;
        max-height: 100vh;
        overflow: hidden;
        background: #1b1b1b;
    }
    canvas {
        display: block;
        width: 100%;
        height: 100%;
        background: #2f5e2f; /* grass */
        touch-action: none;
    }
    /* HUD */
    #hud {
        position: absolute;
        top: 8px;
        left: 8px;
        color: #fff;
        font: var(--hud-font);
        text-shadow: 0 0 3px #000;
        pointer-events: none;
    }
    #hud div {
        margin-bottom: 4px;
    }

    /* Mobile controls */
    #controls {
        position: absolute;
        bottom: 8vh;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        padding: 0 5vw;
        pointer-events: none;
    }
    .control-group {
        display: flex;
        gap: 3vw;
        pointer-events: auto;
        align-items: center;
        justify-content: center;
    }
    .control-btn {
        width: 18vw;
        height: 18vw;
        max-width: 90px;
        max-height: 90px;
        min-width: 60px;
        min-height: 60px;
        border-radius: 50%;
        border: 2px solid rgba(255,255,255,0.7);
        background: rgba(255,255,255,0.08);
        color: #fff;
        font: bold 20px Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        touch-action: none;
    }
    .control-btn:active {
        background: rgba(255,255,255,0.2);
    }
    #gasBtn {
        background: rgba(0,200,0,0.25);
        border-color: rgba(0,255,0,0.8);
    }
    #brakeBtn {
        background: rgba(200,0,0,0.25);
        border-color: rgba(255,0,0,0.8);
    }

    /* Steering wheel */
    #steeringWheel {
        position: relative;
        border-radius: 50%;
        border: 4px solid rgba(255,255,255,0.9);
        background: rgba(0,0,0,0.25);
        width: 26vw;
        height: 26vw;
        max-width: 140px;
        max-height: 140px;
        min-width: 90px;
        min-height: 90px;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
    }
    #steeringWheel::before {
        content: "";
        position: absolute;
        width: 60%;
        height: 8%;
        background: rgba(255,255,255,0.85);
        border-radius: 999px;
    }
    @media (orientation: landscape) {
        #controls {
            bottom: 4vh;
        }
    }
</style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div>Speed: <span id="speedValue">0</span> km/h</div>
        <div>Distance: <span id="distanceValue">0</span> m</div>
        <div>Time: <span id="timeValue">0.0</span> s</div>
        <div>Laps: <span id="lapValue">0</span></div>
    </div>

    <div id="controls">
        <div class="control-group" id="steerGroup">
            <div id="steeringWheel"></div>
        </div>
        <div class="control-group" id="pedalGroup">
            <div class="control-btn" id="gasBtn">▲</div>
            <div class="control-btn" id="brakeBtn">▼</div>
        </div>
    </div>
</div>

<script>
/* ---------- Canvas & sizing (no aspect forcing) ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    const container = document.getElementById('gameContainer');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---------- InputHandler class with steering wheel ---------- */
class InputHandler {
    constructor() {
        this.keys = { w: false, s: false, a: false, d: false };
        this.touch = { gas: false, brake: false };
        this.wheelSteer = 0; // -1..1 from steering wheel

        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            if (['w','a','s','d'].includes(key)) {
                this.keys[key] = true;
                e.preventDefault();
            }
        }, { passive: false });

        window.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();
            if (['w','a','s','d'].includes(key)) {
                this.keys[key] = false;
                e.preventDefault();
            }
        }, { passive: false });

        const gasBtn = document.getElementById('gasBtn');
        const brakeBtn = document.getElementById('brakeBtn');

        const startGas = e => { e.preventDefault(); this.touch.gas = true; };
        const endGas   = e => { e.preventDefault(); this.touch.gas = false; };
        const startBrake = e => { e.preventDefault(); this.touch.brake = true; };
        const endBrake   = e => { e.preventDefault(); this.touch.brake = false; };

        gasBtn.addEventListener('touchstart', startGas, { passive: false });
        gasBtn.addEventListener('touchend', endGas, { passive: false });
        gasBtn.addEventListener('touchcancel', endGas, { passive: false });
        gasBtn.addEventListener('mousedown', startGas);
        window.addEventListener('mouseup', endGas);

        brakeBtn.addEventListener('touchstart', startBrake, { passive: false });
        brakeBtn.addEventListener('touchend', endBrake, { passive: false });
        brakeBtn.addEventListener('touchcancel', endBrake, { passive: false });
        brakeBtn.addEventListener('mousedown', startBrake);
        window.addEventListener('mouseup', endBrake);

        // Steering wheel control
        this.initSteeringWheel();

        document.body.addEventListener('touchmove', e => {
            e.preventDefault();
        }, { passive: false });
    }

    initSteeringWheel() {
        const wheel = document.getElementById('steeringWheel');
        let active = false;
        let center = { x: 0, y: 0 };
        let currentAngle = 0;

        const updateCenter = () => {
            const rect = wheel.getBoundingClientRect();
            center.x = rect.left + rect.width / 2;
            center.y = rect.top + rect.height / 2;
        };
        updateCenter();
        window.addEventListener('resize', updateCenter);

        const handlePointer = (clientX, clientY) => {
            const dx = clientX - center.x;
            const dy = clientY - center.y;
            const angle = Math.atan2(dy, dx); // -PI..PI
            currentAngle = angle;
            wheel.style.transform = `rotate(${angle}rad)`;
            const maxAngle = Math.PI / 3; // 60°
            let steer = angle / maxAngle;
            if (steer > 1) steer = 1;
            if (steer < -1) steer = -1;
            this.wheelSteer = steer;
        };

        const start = e => {
            active = true;
            const t = e.touches ? e.touches[0] : e;
            handlePointer(t.clientX, t.clientY);
        };
        const move = e => {
            if (!active) return;
            const t = e.touches ? e.touches[0] : e;
            handlePointer(t.clientX, t.clientY);
        };
        const end = () => {
            active = false;
            this.wheelSteer = 0;
            wheel.style.transform = 'rotate(0rad)';
        };

        wheel.addEventListener('touchstart', start, { passive: false });
        wheel.addEventListener('touchmove', move, { passive: false });
        wheel.addEventListener('touchend', end, { passive: false });
        wheel.addEventListener('touchcancel', end, { passive: false });

        wheel.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
    }

    getAcceleration() {
        const forward = this.keys.w || this.touch.gas;
        const backward = this.keys.s || this.touch.brake;
        if (forward && !backward) return 1;
        if (backward && !forward) return -1;
        return 0;
    }

    getSteering() {
        // Keyboard steering plus wheel steering combined
        const left = this.keys.a;
        const right = this.keys.d;
        let kb = 0;
        if (left && !right) kb = -1;
        else if (right && !left) kb = 1;

        // If wheel is in use, prefer it; otherwise use keyboard
        if (Math.abs(this.wheelSteer) > 0.05) return this.wheelSteer;
        return kb;
    }
}

/* ---------- Obstacle class ---------- */
class Obstacle {
    constructor(x, y, w, h, type = 'cone') {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.type = type;
    }
    draw(ctx) {
        ctx.save();
        if (this.type === 'cone') ctx.fillStyle = '#ffb347';
        else if (this.type === 'rock') ctx.fillStyle = '#777';
        else ctx.fillStyle = '#aa0000';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.restore();
    }
}

/* ---------- Track class ---------- */
class Track {
    constructor() {
        // Use canvas size on creation; will still work as we only use ratios loosely
        const w = canvas.width;
        const h = canvas.height;
        const margin = 0.06 * w;

        this.roadOuter = { x: margin, y: margin, w: w - 2*margin, h: h - 2*margin };
        this.roadInner = {
            x: this.roadOuter.x + this.roadOuter.w * 0.22,
            y: this.roadOuter.y + this.roadOuter.h * 0.2,
            w: this.roadOuter.w * 0.56,
            h: this.roadOuter.h * 0.6
        };

        const o = this.roadOuter;
        const i = this.roadInner;
        const bw = 0.018 * w;
        const bh = 0.025 * h;
        this.boundaries = [];

        this.boundaries.push({ x: o.x, y: o.y, w: o.w, h: bh });
        this.boundaries.push({ x: o.x, y: o.y + o.h - bh, w: o.w, h: bh });
        this.boundaries.push({ x: o.x, y: o.y, w: bw, h: o.h });
        this.boundaries.push({ x: o.x + o.w - bw, y: o.y, w: bw, h: o.h });

        this.boundaries.push({ x: i.x, y: i.y, w: i.w, h: bh });
        this.boundaries.push({ x: i.x, y: i.y + i.h - bh, w: i.w, h: bh });
        this.boundaries.push({ x: i.x, y: i.y, w: bw, h: i.h });
        this.boundaries.push({ x: i.x + i.w - bw, y: i.y, w: bw, h: i.h });

        const obSize = 0.03 * w;
        this.obstacles = [
            new Obstacle(o.x + o.w * 0.12, o.y + o.h * 0.15, obSize, obSize, 'cone'),
            new Obstacle(o.x + o.w * 0.35, o.y + o.h * 0.8, obSize, obSize, 'rock'),
            new Obstacle(o.x + o.w * 0.7, o.y + o.h * 0.7, obSize * 1.2, obSize * 0.7, 'roadblock'),
            new Obstacle(o.x + o.w * 0.85, o.y + o.h * 0.3, obSize, obSize, 'cone'),
            new Obstacle(o.x + o.w * 0.55, o.y + o.h * 0.45, obSize, obSize, 'rock'),
            new Obstacle(o.x + o.w * 0.25, o.y + o.h * 0.4, obSize * 1.1, obSize * 0.7, 'roadblock')
        ];

        this.lapLine = {
            x1: o.x + o.w * 0.12,
            y1: o.y + bh,
            x2: o.x + o.w * 0.12,
            y2: o.y + o.h - bh
        };
    }

    draw(ctx) {
        ctx.save();
        ctx.fillStyle = '#555';
        ctx.fillRect(this.roadOuter.x, this.roadOuter.y, this.roadOuter.w, this.roadOuter.h);

        ctx.fillStyle = '#2f5e2f';
        ctx.fillRect(this.roadInner.x, this.roadInner.y, this.roadInner.w, this.roadInner.h);

        ctx.fillStyle = '#222';
        for (const b of this.boundaries) ctx.fillRect(b.x, b.y, b.w, b.h);

        ctx.strokeStyle = '#ddd';
        ctx.setLineDash([10, 8]);
        ctx.lineWidth = 2;
        ctx.strokeRect(
            this.roadInner.x + this.roadInner.w * 0.08,
            this.roadInner.y + this.roadInner.h * 0.08,
            this.roadInner.w * 0.84,
            this.roadInner.h * 0.84
        );
        ctx.setLineDash([]);

        for (const ob of this.obstacles) ob.draw(ctx);

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.lapLine.x1, this.lapLine.y1);
        ctx.lineTo(this.lapLine.x2, this.lapLine.y2);
        ctx.stroke();
        ctx.restore();
    }

    checkRectCollision(carRect, rect) {
        return !(
            carRect.x > rect.x + rect.w ||
            carRect.x + carRect.w < rect.x ||
            carRect.y > rect.y + rect.h ||
            carRect.y + carRect.h < rect.y
        );
    }

    checkCollision(carRect) {
        for (const b of this.boundaries) {
            if (this.checkRectCollision(carRect, b)) return true;
        }
        for (const ob of this.obstacles) {
            if (this.checkRectCollision(carRect, { x: ob.x, y: ob.y, w: ob.w, h: ob.h })) return true;
        }
        return false;
    }

    pointSideOfLapLine(x, y) {
        const L = this.lapLine;
        const vx = L.x2 - L.x1;
        const vy = L.y2 - L.y1;
        const wx = x - L.x1;
        const wy = y - L.y1;
        return Math.sign(vx * wy - vy * wx);
    }
}

/* ---------- Car class ---------- */
class Car {
    constructor(x, y) {
        const base = Math.min(canvas.width, canvas.height);
        this.width = base * 0.05;
        this.height = this.width * 0.5;
        this.x = x;
        this.y = y;
        this.angle = 0;
        this.speed = 0;
        this.maxSpeed = 0.45;
        this.accelerationRate = 0.0006;
        this.brakeRate = 0.001;
        this.friction = 0.985;
        this.steeringFactor = 0.004;
        this.driftFactor = 0.96;
        this.distanceTravelled = 0;
        this.lastX = x;
        this.lastY = y;
        this.lastLapSide = 0;
        this.laps = 0;
    }

    getRect() {
        return {
            x: this.x - this.width / 2,
            y: this.y - this.height / 2,
            w: this.width,
            h: this.height
        };
    }

    update(dt, input, track) {
        this.lastX = this.x;
        this.lastY = this.y;

        const accelInput = input.getAcceleration();
        if (accelInput > 0) this.speed += this.accelerationRate * dt;
        else if (accelInput < 0) this.speed -= this.brakeRate * dt;

        if (this.speed > this.maxSpeed) this.speed = this.maxSpeed;
        if (this.speed < -this.maxSpeed * 0.5) this.speed = -this.maxSpeed * 0.5;

        this.speed *= this.friction;

        const steerInput = input.getSteering();
        if (Math.abs(steerInput) > 0.01 && Math.abs(this.speed) > 0.0002) {
            this.angle += steerInput * this.steeringFactor * dt * (this.speed / this.maxSpeed);
        }

        if (Math.abs(steerInput) > 0.1 && Math.abs(this.speed) > this.maxSpeed * 0.5) {
            this.speed *= this.driftFactor;
        }

        if (this.angle > Math.PI) this.angle -= Math.PI * 2;
        if (this.angle < -Math.PI) this.angle += Math.PI * 2;

        const dx = Math.cos(this.angle) * this.speed * dt;
        const dy = Math.sin(this.angle) * this.speed * dt;
        this.x += dx;
        this.y += dy;

        const segDist = Math.hypot(this.x - this.lastX, this.y - this.lastY);
        this.distanceTravelled += segDist;

        const rect = this.getRect();
        if (track.checkCollision(rect)) {
            this.x -= dx * 1.5;
            this.y -= dy * 1.5;
            this.speed *= -0.3;
        }

        const side = track.pointSideOfLapLine(this.x, this.y);
        if (this.lastLapSide !== 0 && side !== 0 && side !== this.lastLapSide) {
            this.laps += 0.5;
        }
        this.lastLapSide = side;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.beginPath();
        ctx.ellipse(0, this.height * 0.3, this.width * 0.55, this.height * 0.7, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#1e88e5';
        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

        ctx.fillStyle = '#bbdefb';
        ctx.fillRect(-this.width * 0.2, -this.height * 0.4, this.width * 0.4, this.height * 0.8);

        ctx.fillStyle = '#eeeeee';
        ctx.fillRect(this.width / 2 - this.width * 0.08, -this.height / 2 + this.height * 0.15,
                     this.width * 0.06, this.height - this.height * 0.3);

        ctx.restore();
    }
}

/* ---------- Game state ---------- */
const input = new InputHandler();
let track = new Track();
let car = new Car(track.roadOuter.x + track.roadOuter.w * 0.15,
                  track.roadOuter.y + track.roadOuter.h * 0.5);

const hudSpeed = document.getElementById('speedValue');
const hudDistance = document.getElementById('distanceValue');
const hudTime = document.getElementById('timeValue');
const hudLap = document.getElementById('lapValue');

let lastTimestamp = performance.now();
let elapsedTime = 0;

/* ---------- Game loop ---------- */
function loop(timestamp) {
    const dt = timestamp - lastTimestamp;
    lastTimestamp = timestamp;
    elapsedTime += dt;

    car.update(dt, input, track);

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    track.draw(ctx);
    car.draw(ctx);

    const speedKmh = Math.abs(car.speed) * 3600;
    hudSpeed.textContent = speedKmh.toFixed(0);
    hudDistance.textContent = (car.distanceTravelled).toFixed(0);
    hudTime.textContent = (elapsedTime / 1000).toFixed(1);
    hudLap.textContent = car.laps.toFixed(1);

    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
