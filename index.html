<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>HD Car Game — Simplified Steering</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
  canvas { display:block; touch-action:none; }
  #steer{position:fixed;bottom:20px;left:20px;}
</style>
</head>
<body>

<canvas id="game"></canvas>
<canvas id="steer" width="180" height="180"></canvas>

<script>
// ------------ setup ------------
const c = document.getElementById('game');
const ctx = c.getContext('2d');
const steer = document.getElementById('steer');
const sctx = steer.getContext('2d');
function resize(){ c.width = innerWidth; c.height = innerHeight; }
resize(); onresize = resize;

// ------------ game state (simplified physics) ------------
let speed = 4.2;       // base forward speed (auto)
let score = 0;
let steeringValue = 0; // -1..1
let steeringTouch = false;

let player = { x: c.width/2, y: c.height - 220, w:60, h:120, visualAngle:0 };

// traffic: fewer cars, slower
let traffic = [];
function spawnOne(){
  const type = Math.random()<0.2? 'truck':'car';
  const w = type==='truck'?80:52;
  const h = type==='truck'?150:110;
  traffic.push({ x: c.width/2 - 120 + Math.random()*240, y: -150 - Math.random()*800, w, h, type, color: randomColor(), speed: 2 + Math.random()*2 });
}
// start with 4 traffic
for(let i=0;i<4;i++) spawnOne();
setInterval(()=>{ if(traffic.length < 8) spawnOne(); }, 2000);

function randomColor(){ const colors=['#ff6666','#66ccff','#ffd166','#8aff7a','#ff8ad1']; return colors[(Math.random()*colors.length)|0]; }

// ------------ draw helpers ------------
CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){ if(!r) r=6; this.beginPath(); this.moveTo(x+r,y); this.arcTo(x+w,y,x+w,y+h,r); this.arcTo(x+w,y+h,x,y+h,r); this.arcTo(x,y+h,x,y,r); this.arcTo(x,y,x+w,y,r); this.closePath(); };

function drawRoad(){
  // side grass
  ctx.fillStyle = '#1e1e1e'; ctx.fillRect(0,0,c.width,c.height);
  // road
  const rw=300; const rx=c.width/2 - rw/2;
  let grad = ctx.createLinearGradient(0,0,0,c.height);
  grad.addColorStop(0,'#2a2a2a'); grad.addColorStop(1,'#1f1f1f');
  ctx.fillStyle = grad; ctx.fillRect(rx,0,rw,c.height);
  // lane dashed center
  ctx.setLineDash([40,40]); ctx.strokeStyle='#f2f2f2'; ctx.lineWidth=6;
  ctx.beginPath(); ctx.moveTo(c.width/2,0); ctx.lineTo(c.width/2,c.height); ctx.stroke(); ctx.setLineDash([]);
}

function drawPlayer(){
  const o = player;
  ctx.save(); ctx.translate(o.x,o.y);
  ctx.rotate(o.visualAngle);
  // body gradient
  const gw = ctx.createLinearGradient(-o.w/2,-o.h/2,o.w/2,o.h/2);
  gw.addColorStop(0,'#23334d'); gw.addColorStop(1,'#1f8fd3');
  ctx.fillStyle = gw; ctx.roundRect(-o.w/2,-o.h/2,o.w,o.h,12); ctx.fill();
  // windows
  ctx.fillStyle='rgba(200,230,255,0.85)'; ctx.fillRect(-o.w/2+8,-o.h/2+16,o.w-16,28);
  ctx.restore();
}

function drawTraffic(t){
  ctx.save(); ctx.translate(t.x,t.y);
  if(t.type==='truck'){
    // trailer box
    ctx.fillStyle='#666'; ctx.fillRect(-t.w/2,-t.h/2,t.w,t.h*0.6);
    ctx.fillStyle=t.color; ctx.fillRect(-t.w/2,t.h*0.1,t.w,t.h*0.9);
  } else {
    ctx.fillStyle=t.color; ctx.roundRect(-t.w/2,-t.h/2,t.w,t.h,8); ctx.fill();
  }
  ctx.restore();
}

// ------------ steering wheel (visual & input) ------------
function drawSteer(a=0){
  sctx.clearRect(0,0,180,180);
  sctx.save(); sctx.translate(90,90); sctx.rotate(a);
  sctx.lineWidth=14; sctx.strokeStyle='#222'; sctx.beginPath(); sctx.arc(0,0,68,0,Math.PI*2); sctx.stroke();
  sctx.lineWidth=8; sctx.strokeStyle='#ffcc00'; sctx.beginPath(); sctx.moveTo(0,-68); sctx.lineTo(0,-36); sctx.stroke();
  sctx.restore();
}
drawSteer();

steer.addEventListener('touchstart', (e)=>{ steeringTouch=true; e.preventDefault(); });
steer.addEventListener('touchend', (e)=>{ steeringTouch=false; steeringValue=0; drawSteer(0); e.preventDefault(); });
steer.addEventListener('touchmove', (e)=>{
  const t = e.touches[0]; const r = steer.getBoundingClientRect();
  const dx = t.clientX - (r.left + r.width/2);
  // steeringValue: -1..1 where negative = left, positive = right
  steeringValue = Math.max(-1, Math.min(1, dx/60));
  // draw wheel matching touch direction (no inversion)
  drawSteer(steeringValue*0.5);
  e.preventDefault();
});

// ------------ main loop (simplified movement) ------------
function loop(){
  ctx.clearRect(0,0,c.width,c.height);
  drawRoad();

  // AUTO forward speed slowly increases with score
  speed = 4 + score*0.002;

  // steering only affects lateral movement and visual tilt
  const steerStrength = 6; // how fast car moves sideways
  player.x += steeringValue * steerStrength;
  player.visualAngle = steeringValue * 0.25; // small tilt

  // forward motion — constant
  player.y -= speed;
  // keep player vertically near bottom
  if(player.y < c.height/3) player.y = c.height/3;

  // keep on road
  const left = c.width/2 - 140, right = c.width/2 + 140;
  if(player.x < left) player.x = left;
  if(player.x > right) player.x = right;

  // draw player
  drawPlayer();

  // traffic movement
  for(let t of traffic){
    t.y += t.speed + speed*0.2; // traffic flows towards player
    drawTraffic(t);
    // recycle offscreen
    if(t.y > c.height + 200){ t.y = -200 - Math.random()*800; t.x = c.width/2 - 100 + Math.random()*200; t.color = randomColor(); score++; }

    // collision simple box
    if(Math.abs(player.x - t.x) < (player.w+t.w)/2 - 12 && Math.abs(player.y - t.y) < (player.h+t.h)/2 - 20){
      // on collision: reset player near bottom, small penalty
      player.x = c.width/2; player.y = c.height - 220; steeringValue = 0; drawSteer(0);
      // reduce speed a bit and reduce score
      score = Math.max(0, score - 5);
    }
  }

  // draw score
  ctx.fillStyle='white'; ctx.font='18px system-ui'; ctx.fillText('Score: '+score, 12, 28);

  requestAnimationFrame(loop);
}
loop();

</script>
</body>
</html>
