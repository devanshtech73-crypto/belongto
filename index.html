<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>SlowRoads-like — Mountain Road Prototype</title>
<style>
  html,body{height:100%;margin:0;background:#0b0b12;overflow:hidden}
  #ui{position:fixed;left:12px;top:12px;color:#fff;font-family:system-ui,Arial;font-weight:600;z-index:10}
  #hint{position:fixed;right:12px;top:12px;color:#ddd;font-family:system-ui,Arial;text-align:right;z-index:10}
  canvas{display:block}
</style>
</head>
<body>
<div id="ui">W/S: throttle/brake • A/D: steer • Score: <span id="score">0</span></div>
<div id="hint">Third-person back view • Mountain road with hills & trees</div>

<script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>

<script>
/* -------------------- Utilities: Perlin noise (compact) -------------------- */
const Perlin = (function(){
  const PERM = new Uint8Array(512);
  (function init(){ const p = new Uint8Array(256); for(let i=0;i<256;i++)p[i]=i; for(let i=255;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); const t=p[i]; p[i]=p[j]; p[j]=t; } for(let i=0;i<512;i++) PERM[i]=p[i&255]; })();
  function fade(t){ return t*t*t*(t*(t*6-15)+10); }
  function lerp(a,b,t){ return a + t*(b-a); }
  function grad(hash,x,y,z){ const h = hash & 15; const u = h<8 ? x : y; const v = h<4 ? y : (h===12||h===14 ? x : z); return ((h&1)? -u : u) + ((h&2)? -v : v); }
  return {
    noise(x,y,z=0){
      const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
      x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
      const u = fade(x), v = fade(y), w = fade(z);
      const A = PERM[X]+Y, AA = PERM[A]+Z, AB = PERM[A+1]+Z;
      const B = PERM[X+1]+Y, BA = PERM[B]+Z, BB = PERM[B+1]+Z;
      return lerp(lerp(lerp(grad(PERM[AA], x, y, z), grad(PERM[BA], x-1, y, z), u),
                       lerp(grad(PERM[AB], x, y-1, z), grad(PERM[BB], x-1, y-1, z), u), v),
                  lerp(lerp(grad(PERM[AA+1], x, y, z-1), grad(PERM[BA+1], x-1, y, z-1), u),
                       lerp(grad(PERM[AB+1], x, y-1, z-1), grad(PERM[BB+1], x-1, y-1, z-1), u), v), w);
    }
  };
})();

/* -------------------- Basic Three.js setup -------------------- */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x091017, 0.0006);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(2, devicePixelRatio));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(60,2,0.1,10000);
camera.position.set(0,6,-10);

function onResize(){
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', onResize, false);
onResize();

/* -------------------- Lighting -------------------- */
const hemi = new THREE.HemisphereLight(0xBBD1FF, 0x202040, 0.6);
scene.add(hemi);

const sun = new THREE.DirectionalLight(0xfff6e6, 1.0);
sun.position.set(40,80,-30);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.left = -200; sun.shadow.camera.right = 200; sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
sun.shadow.camera.far = 600;
scene.add(sun);

/* -------------------- Terrain (high-res plane displaced by Perlin) -------------------- */
const terrain = new THREE.Group();
scene.add(terrain);

const TERRAIN_SIZE = 4000;
const SEG = 200; // more segments -> higher resolution
const planeGeo = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, SEG, SEG);
planeGeo.rotateX(-Math.PI/2);

// displace vertices with layered noise for hills & mountains
for(let i=0;i<planeGeo.attributes.position.count;i++){
  const x = planeGeo.attributes.position.getX(i);
  const z = planeGeo.attributes.position.getZ(i);
  const nx = x * 0.002;
  const nz = z * 0.002;
  const e = Perlin.noise(nx*1.0, nz*1.0)*12 + Perlin.noise(nx*0.5, nz*0.5)*25 + Perlin.noise(nx*3.0, nz*3.0)*2;
  planeGeo.attributes.position.setY(i, e);
}
planeGeo.computeVertexNormals();

// create grass texture procedurally (canvas)
function makeGrassTexture(){
  const s = 1024;
  const cv = document.createElement('canvas'); cv.width=s; cv.height=s;
  const g = cv.getContext('2d');
  // base green
  g.fillStyle = '#2c6a2a'; g.fillRect(0,0,s,s);
  // random blades
  for(let i=0;i<7000;i++){
    const x = Math.random()*s, y = Math.random()*s;
    const h = 6 + Math.random()*12;
    g.strokeStyle = `rgba(${30+Math.random()*40},${80+Math.random()*80},${30+Math.random()*30},${0.6+Math.random()*0.4})`;
    g.lineWidth = 1;
    g.beginPath(); g.moveTo(x,y); g.lineTo(x + (Math.random()-0.5)*4, y - h); g.stroke();
  }
  const tex = new THREE.CanvasTexture(cv);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(8,8);
  return tex;
}
const grassTex = makeGrassTexture();

const terrainMat = new THREE.MeshStandardMaterial({ map: grassTex, roughness:0.95, metalness:0.02 });
const terrainMesh = new THREE.Mesh(planeGeo, terrainMat);
terrainMesh.receiveShadow = true;
terrain.add(terrainMesh);
terrain.position.y = -6;

/* -------------------- Road (spline with elevation from noise) -------------------- */
const roadGroup = new THREE.Group();
scene.add(roadGroup);

const roadCurvePts = [];
const ROAD_LENGTH = 8000;
const roadStep = 8;
for(let z=0; z>-ROAD_LENGTH; z -= roadStep){
  // centerline x offset from noise (curve)
  const t = z * -0.002;
  const cx = Perlin.noise(t*0.7, 0.1)*6 + Perlin.noise(t*0.13, 2.3)*18;
  const height = Perlin.noise(t*0.8, 0.2)*10 + Perlin.noise(t*0.04, 0.6)*35;
  roadCurvePts.push(new THREE.Vector3(cx, height, z));
}

// make road mesh by sampling cross sections along the curve
function buildRoadMesh(){
  const roadWidth = 6.5;
  const geometry = new THREE.BufferGeometry();
  const verts = [], normals = [], uvs = [], indices = [];
  for(let i=0;i<roadCurvePts.length-1;i++){
    const a = roadCurvePts[i].clone();
    const b = roadCurvePts[i+1].clone();
    const dir = b.clone().sub(a); dir.y = 0;
    const left = new THREE.Vector3(-dir.z,0,dir.x).normalize().multiplyScalar(roadWidth);
    const r = a.clone().add(left);
    const l = a.clone().add(left.multiplyScalar(-1));
    const r2 = b.clone().add(new THREE.Vector3(-dir.z,0,dir.x).normalize().multiplyScalar(roadWidth));
    const l2 = b.clone().add(new THREE.Vector3(-dir.z,0,dir.x).normalize().multiplyScalar(-roadWidth));
    verts.push(r.x, a.y+0.05, r.z, l.x, a.y+0.05, l.z, r2.x, b.y+0.05, r2.z, l2.x, b.y+0.05, l2.z);
    const base = i*4;
    indices.push(base, base+1, base+2, base+2, base+1, base+3);
    uvs.push(0, i/roadCurvePts.length, 1, i/roadCurvePts.length, 0, (i+1)/roadCurvePts.length, 1, (i+1)/roadCurvePts.length);
  }
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();
  // road material: dark asphalt with slight sheen
  const mat = new THREE.MeshStandardMaterial({ color:0x141515, roughness:0.6, metalness:0.05 });
  const mesh = new THREE.Mesh(geometry, mat);
  mesh.receiveShadow = true;
  return mesh;
}
const roadMesh = buildRoadMesh();
scene.add(roadMesh);

/* -------------------- Trees (clusters using cones) -------------------- */
const treeGroup = new THREE.Group();
scene.add(treeGroup);

function makeTree(){
  const g = new THREE.Group();
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,1.0), new THREE.MeshStandardMaterial({color:0x6b3b1f}));
  trunk.position.y = 0.5; trunk.castShadow = true; g.add(trunk);
  const leafMat = new THREE.MeshStandardMaterial({ color:0x1f6e2f });
  const cone1 = new THREE.Mesh(new THREE.ConeGeometry(0.9,1.3,8), leafMat);
  cone1.position.y = 1.45; cone1.castShadow = true; g.add(cone1);
  const cone2 = cone1.clone(); cone2.scale.set(0.8,0.8,0.8); cone2.position.y = 2.1; g.add(cone2);
  return g;
}
// scatter many trees along terrain, but avoid road center
for(let i=0;i<800;i++){
  const x = (Math.random() - 0.5) * TERRAIN_SIZE * 0.9;
  const z = -Math.random() * (ROAD_LENGTH*0.9);
  // avoid river close to road centerline: use noise centerline to compute nearest
  // approximate nearest road x by sampling a few pts (cheap)
  // compute terrain height from plane
  const nx = x * 0.002, nz = z * 0.002;
  const h = Perlin.noise(nx*1.0, nz*1.0)*12 + Perlin.noise(nx*0.5, nz*0.5)*25;
  const t = makeTree();
  t.position.set(x, h, z);
  t.scale.setScalar(0.9 + Math.random()*0.8);
  // avoid placing on the actual road corridor (approx)
  const roadXAtZ = roadCurvePts[Math.floor(Math.abs(z)/roadStep)]?.x || 0;
  if(Math.abs(x - roadXAtZ) < 18) {
    i--; continue;
  }
  treeGroup.add(t);
}

/* -------------------- Mountains (distant) -------------------- */
const mountainGeo = new THREE.ConeGeometry(120, 400, 8);
const mountainMat = new THREE.MeshStandardMaterial({ color:0x3b3b44, roughness:1 });
for(let i=0;i<8;i++){
  const m = new THREE.Mesh(mountainGeo, mountainMat);
  m.position.set((Math.random()-0.5)*2000, 80, -800 - Math.random()*2000);
  m.rotation.y = Math.random()*Math.PI;
  m.receiveShadow = true; m.castShadow = true;
  scene.add(m);
}

/* -------------------- Player car (detailed procedural) -------------------- */
function makePlayerCar(){
  const group = new THREE.Group();
  // body
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.6,4.0), new THREE.MeshStandardMaterial({ color: 0x2d9bf0, metalness:0.3, roughness:0.2 }));
  body.position.y = 1.0; body.castShadow = true; group.add(body);
  // cabin
  const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.45,1.8), new THREE.MeshStandardMaterial({ color: 0xa8e0ff, opacity:0.9, transparent:true }));
  cabin.position.set(0,1.25,-0.1); cabin.castShadow = true; group.add(cabin);
  // wheels
  const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.5,16);
  const wheelMat = new THREE.MeshStandardMaterial({ color:0x111, roughness:0.8 });
  const wheelPos = [[-0.9,0.45,1.3],[0.9,0.45,1.3],[-0.9,0.45,-1.3],[0.9,0.45,-1.3]];
  wheelPos.forEach(p=>{
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI/2; w.position.set(p[0], p[1], p[2]); w.castShadow = true; group.add(w);
  });
  // small spoiler
  const spoiler = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.08,0.2), new THREE.MeshStandardMaterial({ color:0x1a6aa0 }));
  spoiler.position.set(0,1.28,-2.05); spoiler.castShadow = true; group.add(spoiler);
  return group;
}
const playerCar = makePlayerCar();
scene.add(playerCar);

/* -------------------- State and controls -------------------- */
const state = {
  speed: 18,        // base medium speed units
  maxSpeed: 50,
  accel: 10,
  braking: 28,
  lateral: 0,       // meters offset from centerline
  heading: 0,
  score: 0
};

const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
window.addEventListener('keydown', e=>{ if(e.key in keys) keys[e.key]=true; if(e.key==='m') mouseSteer=!mouseSteer; });
window.addEventListener('keyup', e=>{ if(e.key in keys) keys[e.key]=false; });

let mouseSteer = true, pointerLocked = false;
document.body.addEventListener('click', ()=>{ if(!pointerLocked) renderer.domElement.requestPointerLock?.(); });
document.addEventListener('pointerlockchange', ()=>{ pointerLocked = (document.pointerLockElement === renderer.domElement); });

let mouseDX = 0;
window.addEventListener('mousemove', e=>{ if(pointerLocked && mouseSteer) mouseDX = e.movementX; });

/* -------------------- Camera follow (third person back view) -------------------- */
const camTarget = new THREE.Vector3();
const camLag = 0.12;

/* -------------------- main update loop -------------------- */
let last = performance.now();
function update(){
  const now = performance.now();
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;

  // throttle / brake
  if(keys.ArrowUp) state.speed += state.accel * dt;
  else state.speed -= state.speed * 0.4 * dt; // natural slowdown
  if(keys.ArrowDown) state.speed -= state.braking * dt;
  state.speed = Math.max(6, Math.min(state.maxSpeed, state.speed));

  // steering input
  let steerInput = 0;
  if(keys.ArrowLeft) steerInput -= 1;
  if(keys.ArrowRight) steerInput += 1;
  if(pointerLocked && mouseSteer) steerInput += Math.max(-1, Math.min(1, mouseDX * 0.008));
  mouseDX = 0;

  // lateral movement limited (road half width)
  const steerStrength = 6.0 * (state.speed/20);
  state.lateral += steerInput * steerStrength * dt;
  const roadHalf = 6.5;
  state.lateral = Math.max(-roadHalf + 0.6, Math.min(roadHalf - 0.6, state.lateral));

  // heading smoothing (visual tilt)
  state.heading = state.heading * 0.9 + steerInput * 0.15;

  // advance along the road: we simulate by moving the road & world backwards relative to player
  const forward = state.speed * dt * 6.0; // tuned multiplier for pleasant feel

  // advance road curve progression (move all road points forward in z)
  for(let i=0;i<roadCurvePts.length;i++){ roadCurvePts[i].z += forward; }
  // rebuild road mesh positions by updating geometry positions for performance we cheat by replacing whole mesh occasionally
  if(Math.random() < 0.02){
    scene.remove(roadMesh);
    roadMesh.geometry.dispose();
    const newRoad = buildRoadMesh();
    scene.add(newRoad);
  }

  // move terrain slightly to create motion illusion (cheap)
  terrain.position.z += forward * 0.6;
  treeGroup.position.z += forward * 0.6;
  // reposition far objects to loop
  if(terrain.position.z > 1000) terrain.position.z -= 2000;

  // Player position in world coords: lateral + find elevation from road curve near z ~ 0
  const idx = Math.max(0, Math.min(roadCurvePts.length-1, Math.floor(Math.abs(0)/roadStep)));
  const roadX = roadCurvePts[idx]?.x || 0;
  const roadY = roadCurvePts[idx]?.y || 0;
  playerCar.position.set(state.lateral, roadY + 0.8, 6);

  // camera behind & above the player with smoothing
  camTarget.set(state.lateral, playerCar.position.y + 2.5, playerCar.position.z - 8 - (state.speed/10));
  camera.position.lerp(camTarget, camLag);
  camera.lookAt(playerCar.position.x, playerCar.position.y + 1.2, playerCar.position.z + 6);

  // update HUD score slowly with distance
  state.score += forward * 0.02;
  document.getElementById('score').textContent = Math.floor(state.score);

  renderer.render(scene, camera);
  requestAnimationFrame(update);
}
update();

/* -------------------- Notes --------------------
- This prototype uses a high-resolution terrain mesh (200x200 segments) displaced with Perlin noise.
- The road is a spline generated and extruded as a simple strip; to keep it performant the road mesh is occasionally rebuilt rather than every frame.
- Trees are clustered with cone geometry to provide leaf detail without textures; grass is a procedurally-generated canvas texture repeated on the terrain.
- Speed is tuned down to medium (state.speed base ~ 18); acceleration/brake tuned for PC gameplay.
- No external models — everything is generated procedurally so it runs without downloads.
-------------------------------------------------*/
</script>
</body>
</html>
