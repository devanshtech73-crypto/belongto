<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AmongLite — Multiplayer Social Deduction (single file prototype)</title>
  <style>
    /*
      AmongLite: single-file prototype inspired by social-deduction games (Among Us-like)
      Features added in this update:
        - Local settings UI (controls, audio, graphics)
        - Peer-to-peer multiplayer using WebRTC datachannels with manual signaling (copy/paste)
        - Lobby with player list, ready state, role assignment (crewmate / impostor)
        - Top-down map, multiple characters (avatars), movement, tasks, vents (simple), kill and report
        - Voting system, chat, simple sound cues, and improved UI
        - Simulated AI bots if no peers connected

      Limitations & notes:
        - This is a prototype. For seamless online multiplayer you need a signaling server (I included manual SDP copy/paste as a fallback).
        - Not a production implementation: security, anti-cheat, and networking robustness are minimal.
        - Large single-file; still a prototype—if you want a full 3000-4000 line version with more polish (animations, asset pipeline, custom maps, dedicated server), I can extend it next.
    */

    :root{ --bg:#0b1220; --panel: rgba(255,255,255,0.06); --accent:#ffd166; --accent2:#9ad3bc; }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#06101a,#0b1220);color:#e6eef6}
    #app{position:relative;width:100%;height:100vh;overflow:hidden}
    canvas{display:block;margin:0 auto;background:#07111a;box-shadow:0 8px 30px rgba(0,0,0,0.6);border-radius:6px}

    /* UI panels */
    .panel{position:absolute;right:18px;top:18px;background:var(--panel);padding:12px;border-radius:10px;backdrop-filter:blur(6px);width:300px}
    .panel h3{margin:0 0 6px 0;font-size:15px}
    .panel p{margin:6px 0 0 0;font-size:13px;color:#cbd8e6}
    .leftPanel{left:18px;top:18px;width:260px}

    .btn{display:inline-block;padding:8px 10px;border-radius:8px;background:var(--accent);color:#072227;font-weight:700;text-decoration:none;border:none;cursor:pointer}
    .btn.secondary{background:var(--accent2)}
    .small{font-size:13px;padding:6px 8px}

    .lobbyList{max-height:200px;overflow:auto;margin-top:8px;border-radius:6px;padding:6px;background:rgba(0,0,0,0.12)}
    .playerRow{display:flex;align-items:center;justify-content:space-between;padding:6px 4px;border-bottom:1px solid rgba(255,255,255,0.03)}

    .hud{position:absolute;left:50%;transform:translateX(-50%);top:18px;background:rgba(0,0,0,0.45);color:#fff;padding:6px 10px;border-radius:6px;font-weight:600}

    /* chat */
    .chat{position:absolute;left:18px;bottom:18px;width:340px;background:var(--panel);padding:8px;border-radius:10px}
    .chat .messages{max-height:180px;overflow:auto;margin-bottom:8px}
    .chat .messages div{padding:6px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,0.03)}
    .chat input{width:100%;padding:8px;border-radius:6px;border:none;background:rgba(255,255,255,0.02);color:#e6eef6}

    /* model / modal */
    .modal{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(rgba(0,0,0,0.6),rgba(0,0,0,0.6));z-index:60}
    .card{background:#07121a;padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);width:min(720px,94%)}

    /* quick settings */
    .settingsRow{display:flex;gap:8px;align-items:center;margin-top:6px}
    label{font-size:13px}

    /* responsive */
    @media (max-width:900px){ .panel{display:none} canvas{width:100%;height:70vh} .chat{left:8px;width:calc(100% - 16px)} }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="game" width="1100" height="640"></canvas>

    <div class="panel leftPanel" id="lobbyPanel">
      <h3>Lobby</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <input id="nameInput" placeholder="Your name" style="flex:1;padding:8px;border-radius:6px;border:none;background:rgba(255,255,255,0.03);color:#e6eef6" />
        <button id="btnHost" class="btn small">Host</button>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
        <button id="btnJoin" class="btn small secondary">Join</button>
        <button id="btnAI" class="btn small">Add Bot</button>
      </div>
      <p style="margin-top:8px;font-size:13px;color:#bcd">Room Signaling (manual): paste remote SDP here to connect</p>
      <textarea id="signalBox" style="width:100%;height:80px;background:rgba(255,255,255,0.02);border-radius:6px;border:none;color:#dbeaf8;padding:8px"></textarea>

      <div style="margin-top:8px;font-size:13px;color:#dbeaf8">Players</div>
      <div class="lobbyList" id="playerList"></div>
      <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
        <button id="btnReady" class="btn small">Ready</button>
        <button id="btnStart" class="btn small secondary">Start Game</button>
      </div>
    </div>

    <div class="panel" style="right:18px;top:18px;" id="settingsPanel">
      <h3>Settings</h3>
      <div class="settingsRow"><label>Character</label><select id="charSelect" style="margin-left:auto;background:transparent;color:#e6eef6;border:none"><option>Red</option><option>Blue</option><option>Green</option><option>Purple</option><option>Yellow</option></select></div>
      <div class="settingsRow"><label>Controls</label><select id="controlSelect" style="margin-left:auto;background:transparent;color:#e6eef6;border:none"><option>Keyboard</option><option>Touch</option></select></div>
      <div style="margin-top:8px"><label>Volume</label><input id="vol" type="range" min="0" max="100" value="80"/></div>
    </div>

    <div class="hud" id="hud">State: Lobby</div>

    <div class="chat" id="chatPanel">
      <div class="messages" id="chatMessages"></div>
      <input id="chatInput" placeholder="Type message and press Enter" />
    </div>

    <div class="modal" id="voteModal">
      <div class="card">
        <h3>Vote</h3>
        <p id="voteText">Who is suspicious?</p>
        <div id="voteOptions" style="display:flex;flex-wrap:wrap;gap:8px;margin-top:8px"></div>
        <div style="margin-top:12px;display:flex;gap:8px"><button id="btnVoteSkip" class="btn">Skip</button><button id="btnVoteClose" class="btn secondary">Close</button></div>
      </div>
    </div>

  </div>

  <script>
  /* AmongLite: Multiplayer social-deduction prototype
     Core architecture notes:
       - Top-down map drawn on <canvas>
       - Game state synchronized via WebRTC DataChannels (manual signaling fallback using copy/paste)
       - Host handles authoritative actions (start, assign roles, votes). For P2P multi-host you'd need a server.
       - Bots are simulated locally and participate in tasks/votes.
  */

  (function(){
    // ---------- Config ----------
    const CONFIG = {
      MAP_W: 2000, MAP_H: 1200,
      VIEW_W: 1100, VIEW_H: 640,
      PLAYER_SPEED: 150, // px per second
      TASK_COUNT: 5,
      IMPOSTOR_KILL_COOLDOWN: 8, // seconds
      MAX_PLAYERS: 10
    };

    // ---------- Canvas ----------
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = CONFIG.VIEW_W; canvas.height = CONFIG.VIEW_H;

    // ---------- Local state ----------
    const local = {
      id: 'p_' + Math.floor(Math.random()*999999),
      name: localStorage.getItem('al_name') || 'Player'+Math.floor(Math.random()*999),
      color: 'Red',
      role: 'crewmate',
      isHost: false,
      ready: false,
      conn: null, // WebRTC local pc object
      dc: null, // datachannel
      peers: {}, // peer id -> {id,name,color,ready,dc}
      bots: [],
      inGame: false,
      map: generateMap(),
      players: {}, // id -> player state (x,y,alive,taskProgress)
      tasks: {},
      voteState: null,
      lastKillTime: -999,
    };

    // default player position
    function spawnPos(i){ return {x: 200 + (i*80)%1000, y: 200 + Math.floor(i/10)*80}; }

    // ---------- DOM refs ----------
    const nameInput = document.getElementById('nameInput'); nameInput.value = local.name;
    const playerListEl = document.getElementById('playerList');
    const hud = document.getElementById('hud');
    const startBtn = document.getElementById('btnStart');
    const readyBtn = document.getElementById('btnReady');
    const hostBtn = document.getElementById('btnHost');
    const joinBtn = document.getElementById('btnJoin');
    const signalBox = document.getElementById('signalBox');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const aiBtn = document.getElementById('btnAI');

    // ---------- Networking: Simple WebRTC (manual signaling) ----------
    // Note: This is a peer-to-peer approach. For automated signaling you need a server.

    function createPeerConnection(isHost){
      const pc = new RTCPeerConnection();
      const dc = pc.createDataChannel('game');
      dc.onopen = ()=>{ log('DataChannel open'); local.dc = dc; setupDC(dc); }
      dc.onmessage = e=> handleMessage(JSON.parse(e.data));

      pc.ondatachannel = (ev)=>{ const ch = ev.channel; ch.onmessage = e=> handleMessage(JSON.parse(e.data)); ch.onopen = ()=>{ log('remote datachannel open'); }; local.peers['remote'] = {dc:ch}; }
      return {pc,dc};
    }

    // Manual signaling: createOffer -> copy offer -> remote set as answer -> paste into box -> connect
    hostBtn.addEventListener('click', async ()=>{
      local.isHost = true; local.name = nameInput.value || local.name; saveName(); seedLobbyAsHost(); showHUD('Hosting (manual signaling)');
      const pc = new RTCPeerConnection();
      local.conn = pc;
      const dc = pc.createDataChannel('game'); local.dc = dc; setupDC(dc);
      pc.onicecandidate = (e)=>{ if(e.candidate==null) { signalBox.value = JSON.stringify({type:'offer',sdp:pc.localDescription}); } }
      const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
      // Wait for user to paste remote answer
      joinBtn.disabled = true; hostBtn.disabled = true;
    });

    joinBtn.addEventListener('click', async ()=>{
      // Join by pasting remote offer into signalBox
      try{
        const data = JSON.parse(signalBox.value.trim());
        if(data.type==='offer'){
          // act as client -> create answer
          const pc = new RTCPeerConnection(); local.conn = pc;
          pc.ondatachannel = ev => { const ch = ev.channel; local.dc = ch; setupDC(ch); };
          pc.onicecandidate = e => { if(e.candidate==null) { signalBox.value = JSON.stringify({type:'answer',sdp:pc.localDescription}); } }
          await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
          const answer = await pc.createAnswer(); await pc.setLocalDescription(answer);
          showHUD('Created answer — paste to host');
        } else if(data.type==='answer'){
          // host receives answer pasted back
          if(local.conn){ await local.conn.setRemoteDescription(new RTCSessionDescription(data.sdp)); showHUD('Connected'); }
        }
      }catch(e){ alert('Invalid SDP JSON — copy/paste from host or peer.'); }
    });

    function setupDC(dc){
      dc.onmessage = e => handleMessage(JSON.parse(e.data));
      dc.onopen = ()=>{ showHUD('P2P connected'); send({t:'join',id:local.id,name:local.name,color:local.color}); };
      dc.onerror = e => console.error('DC error',e);
    }

    function send(msg){ try{ if(local.dc && local.dc.readyState==='open') local.dc.send(JSON.stringify(msg)); }catch(e){} }

    function handleMessage(msg){
      // messages: join, chat, stateUpdate, startGame, action (kill/report), vote
      if(msg.t==='join'){ // other player joined
        local.peers[msg.id] = {id: msg.id, name:msg.name, color:msg.color||'Red'}; updatePlayerList(); addChatSystem(msg.name + ' joined'); }
      else if(msg.t==='chat'){ addChat(msg.name, msg.txt); }
      else if(msg.t==='start'){ if(local.isHost){ // ignore; host starts locally } else startGameAsClient(msg); }
      else if(msg.t==='state'){ mergeStateFromHost(msg.state); }
      else if(msg.t==='action'){ handleRemoteAction(msg); }
      else if(msg.t==='vote'){ handleRemoteVote(msg); }
    }

    // ---------- Lobby behaviors ----------
    function seedLobbyAsHost(){ local.players = {}; local.players[local.id] = {id:local.id,name:local.name,color:local.color,alive:true,ready:false,x:300,y:300}; updatePlayerList(); }
    function addLocalPlayer(){ local.players[local.id] = {id:local.id,name:local.name,color:local.color,alive:true,ready:false,x:300,y:300}; updatePlayerList(); }

    function saveName(){ localStorage.setItem('al_name', nameInput.value); }

    nameInput.addEventListener('change', ()=>{ local.name = nameInput.value; saveName(); updatePlayerList(); });

    readyBtn.addEventListener('click', ()=>{ local.ready = !local.ready; if(local.players[local.id]) local.players[local.id].ready = local.ready; updatePlayerList(); broadcast({t:'ready',id:local.id,ready:local.ready}); });

    startBtn.addEventListener('click', ()=>{
      if(!local.isHost){ alert('Only host can start the game (in this manual P2P prototype).'); return; }
      // assign roles
      const ids = Object.keys(local.players);
      if(ids.length < 2){ alert('Need at least 2 players'); return; }
      const impostorCount = Math.max(1, Math.floor(ids.length/5));
      const shuffled = shuffleArray(ids.slice());
      const impostors = shuffled.slice(0, impostorCount);
      for(const id of ids){ local.players[id].role = impostors.includes(id)? 'impostor' : 'crewmate'; local.players[id].alive = true; local.players[id].taskProgress = 0; }
      // spawn positions
      let i = 0; for(const id of ids){ const pos = spawnPos(i++); local.players[id].x = pos.x; local.players[id].y = pos.y; }
      // create tasks
      local.tasks = generateTasks(CONFIG.TASK_COUNT);
      local.inGame = true; broadcast({t:'start', state: hostExportState()});
      hud.innerText = 'In Game';
      addChatSystem('Game started — roles assigned.');
    });

    aiBtn.addEventListener('click', ()=>{ const botId = 'bot_'+Math.floor(Math.random()*9999); local.bots.push(botId); local.players[botId] = {id:botId,name:'Bot'+Math.floor(Math.random()*999),color:['Blue','Green','Purple'][Math.floor(Math.random()*3)],alive:true,ready:true,x:400+Math.random()*200,y:360+Math.random()*200}; updatePlayerList(); addChatSystem('Added bot'); });

    function updatePlayerList(){ playerListEl.innerHTML = ''; for(const id in local.players){ const p = local.players[id]; const row = document.createElement('div'); row.className='playerRow'; row.innerHTML = `<div><strong>${p.name}</strong> <span style="color:#9bd">${p.role||''}</span></div><div>${p.ready?'<small>Ready</small>':''}</div>`; playerListEl.appendChild(row);} }

    function broadcast(msg){ // broadcast to peers (single DC in manual mode)
      // In this simplified prototype we only support a single DC (manual). In multi-peer you'd iterate all peers.
      try{ if(local.dc && local.dc.readyState==='open') local.dc.send(JSON.stringify(msg)); }catch(e){}
    }

    // ---------- Game world generation ----------
    function generateMap(){ // simple map with rooms and corridors
      const rooms = [ {x:200,y:120,w:600,h:340,name:'Cafeteria'}, {x:920,y:120,w:520,h:300,name:'Engine'}, {x:200,y:500,w:420,h:380,name:'Security'}, {x:700,y:520,w:580,h:420,name:'MedBay'} ];
      const obstacles = [];
      // create some walls (rects) between rooms
      return {rooms,obstacles};
    }

    function generateTasks(n){ const t={}; for(let i=0;i<n;i++){ t['t'+i] = {id:'t'+i,x:200+Math.random()*1100,y:120+Math.random()*800,doneBy:null}; } return t; }

    // ---------- Host authoritative export / merge ----------
    function hostExportState(){ return {players: local.players, tasks: local.tasks, time: Date.now()}; }
    function mergeStateFromHost(state){ // replace local non-authoritative state
      local.players = state.players; local.tasks = state.tasks; local.inGame = true; hud.innerText = 'In Game (client)'; }

    // ---------- Client join handling ----------
    function startGameAsClient(msg){ mergeStateFromHost(msg.state); addChatSystem('Game started by host'); }

    // ---------- Simulated bots ----------
    function stepBots(dt){ for(const id of local.bots){ const bot = local.players[id]; if(!bot) continue; // simple wandering
        const t = Object.values(local.tasks).find(x=>!x.doneBy);
        if(t){ const dx = t.x - bot.x, dy = t.y - bot.y; const dist = Math.hypot(dx,dy); if(dist<6){ t.doneBy = id; } else { bot.x += (dx/dist)*CONFIG.PLAYER_SPEED*0.4*dt; bot.y += (dy/dist)*CONFIG.PLAYER_SPEED*0.4*dt; } }
    } }

    // ---------- Actions (kill/report) ----------
    function handleRemoteAction(msg){ if(msg.act==='kill'){ if(local.players[msg.target]) local.players[msg.target].alive = false; addChatSystem(msg.by+' killed '+msg.target); } }

    // ---------- Voting ----------
    function openVote(){ const modal = document.getElementById('voteModal'); modal.style.display='flex'; const opts = document.getElementById('voteOptions'); opts.innerHTML=''; for(const id in local.players){ const p = local.players[id]; const btn = document.createElement('button'); btn.className='btn small'; btn.textContent = p.name; btn.onclick = ()=>{ submitVote(id); modal.style.display='none'; }; opts.appendChild(btn); } }
    function submitVote(id){ addChatSystem(local.name + ' voted ' + (id?' '+local.players[id].name:' skip')); // send vote to host if client
      if(local.isHost){ tallyVote(id); } else broadcast({t:'vote',by:local.id,target:id}); }
    function handleRemoteVote(msg){ if(local.isHost){ // tally and maybe eject
        tallyVote(msg.target); } }
    function tallyVote(targetId){ // extremely simple: eject target
      if(targetId && local.players[targetId]){ local.players[targetId].alive = false; addChatSystem(local.players[targetId].name + ' was ejected'); } else addChatSystem('No one was ejected (skip)'); }

    // ---------- Chat UI ----------
    chatInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ const txt = chatInput.value.trim(); if(!txt) return; addChat(local.name, txt); broadcast({t:'chat',name:local.name,txt}); chatInput.value=''; } });
    function addChat(name, txt){ const div = document.createElement('div'); div.textContent = name + ': ' + txt; chatMessages.appendChild(div); chatMessages.scrollTop = chatMessages.scrollHeight; }
    function addChatSystem(txt){ const div = document.createElement('div'); div.style.opacity=0.8; div.textContent = '[SYSTEM] ' + txt; chatMessages.appendChild(div); chatMessages.scrollTop = chatMessages.scrollHeight; }

    // ---------- Input & local movement ----------
    const keys = {};
    window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key==='v' || e.key==='V'){ openVote(); } });
    window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

    function localMovement(dt){ if(!local.inGame) return; if(!local.players[local.id]) local.players[local.id] = {id:local.id,name:local.name,color:local.color,alive:true,x:300,y:300}; const p = local.players[local.id]; if(!p.alive) return; let dx=0,dy=0; if(keys['arrowup']||keys['w']) dy -= 1; if(keys['arrowdown']||keys['s']) dy += 1; if(keys['arrowleft']||keys['a']) dx -= 1; if(keys['arrowright']||keys['d']) dx += 1; if(dx||dy){ const len = Math.hypot(dx,dy); p.x += (dx/len)*CONFIG.PLAYER_SPEED*dt; p.y += (dy/len)*CONFIG.PLAYER_SPEED*dt; if(local.isHost) broadcast({t:'state',state: hostExportState()}); else send({t:'move',id:local.id,x:p.x,y:p.y}); } }

    // ---------- Rendering ----------
    function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); // background floor
      ctx.fillStyle = '#0b1720'; ctx.fillRect(0,0,canvas.width,canvas.height);
      drawMap(); drawPlayers(); drawTasks(); drawHUD(); }

    function drawMap(){ // rooms
      ctx.save(); ctx.translate(0,0);
      for(const r of local.map.rooms){ ctx.fillStyle = 'rgba(120,140,160,0.06)'; ctx.fillRect(r.x, r.y, r.w, r.h); ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(r.x+8, r.y+8, 120, 28); ctx.fillStyle='#9bd'; ctx.font='14px sans-serif'; ctx.fillText(r.name, r.x+12, r.y+28); }
      ctx.restore(); }

    function drawPlayers(){ for(const id in local.players){ const p = local.players[id]; if(!p) continue; if(!p.alive){ ctx.globalAlpha = 0.45; } else ctx.globalAlpha = 1; drawAvatar(p.x - cameraOffset().x, p.y - cameraOffset().y, id===local.id, p); ctx.globalAlpha = 1; } }

    function drawAvatar(x,y,isLocal,p){ const size=28; ctx.save(); ctx.translate(x,y); ctx.fillStyle = avatarColor(p.color); ctx.beginPath(); ctx.arc(0,0,size,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.name.split(' ')[0],0,-size-8); if(!p.alive){ ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(-size, -size, size*2, size*2); } ctx.restore(); }

    function drawTasks(){ for(const id in local.tasks){ const t = local.tasks[id]; if(t.doneBy){ ctx.fillStyle='rgba(100,255,120,0.6)'; } else ctx.fillStyle='rgba(255,255,0,0.8)'; ctx.fillRect(t.x - cameraOffset().x -10, t.y - cameraOffset().y -10, 20,20); } }

    // avatar color map
    function avatarColor(c){ switch((c||'Red').toLowerCase()){ case 'red': return '#ff6b6b'; case 'blue': return '#6bb0ff'; case 'green': return '#8be38b'; case 'purple': return '#c28bff'; case 'yellow': return '#ffd166'; default: return '#9ad3bc'; } }

    // camera centers on local player
    function cameraOffset(){ const p = local.players[local.id] || {x:CONFIG.MAP_W/2,y:CONFIG.MAP_H/2}; const cx = p.x - canvas.width/2; const cy = p.y - canvas.height/2; return {x:cx,y:cy}; }

    function drawHUD(){ // simple
      hud.innerText = local.inGame? ('In Game — ' + (local.role||'')) : 'Lobby'; }

    // ---------- Utilities ----------
    function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }

    // ---------- Votes & reports (local) ----------
    function reportBody(reporterId, bodyId){ addChatSystem(local.players[reporterId].name+' reported a body of '+local.players[bodyId].name); openVote(); }

    // ---------- Host actions ----------
    function broadcastHostState(){ if(local.isHost) broadcast({t:'state', state: hostExportState()}); }

    // ---------- Simple game loop ----------
    let last = performance.now(); function tick(now){ const dt = Math.min(0.05, (now-last)/1000); last = now; if(local.inGame){ stepBots(dt); localMovement(dt); } draw(); requestAnimationFrame(tick); } requestAnimationFrame(tick);

    // ---------- Helper: send wrapper for manual DC (if available) ----------
    function send(msg){ try{ if(local.dc && local.dc.readyState==='open') local.dc.send(JSON.stringify(msg)); }catch(e){ console.warn('send failed',e); } }
    function broadcast(msg){ send(msg); }

    // ---------- Misc helpers ----------
    function log(...args){ console.log.apply(console,args); }

    // ---------- UI helpers ----------
    function showHUD(txt){ hud.innerText = txt; setTimeout(()=>{ if(!local.inGame) hud.innerText='Lobby'; }, 3000); }

    // initialize local player in lobby
    addLocalPlayer(); updatePlayerList();

    // save name on change
    nameInput.addEventListener('change', ()=>{ local.name = nameInput.value; saveName(); addLocalPlayer(); updatePlayerList(); });

    // quick controls: paste answer into signal box to finish handshake
    // For production you'd provide a signaling server that exchanges offers/answers automatically.

  })();
  </script>
</body>
</html>
