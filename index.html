<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Top-Down Driving — Demo</title>
<style>
  :root{
    --ui-size: 14px;
  }
  html,body{height:100%;margin:0;background:#111;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  #game-wrap{display:flex;flex-direction:column;height:100vh;align-items:center;justify-content:center;padding:6px;box-sizing:border-box;}
  #ui-row{width:100%;max-width:1100px;display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;}
  .panel{background:rgba(0,0,0,0.4);padding:6px 10px;border-radius:10px;backdrop-filter: blur(4px);box-shadow:0 6px 20px rgba(0,0,0,0.6);}
  #hud{display:flex;gap:8px;align-items:center;}
  #speedo{font-weight:700;font-size:16px;letter-spacing:1px;}
  #timer{font-size:14px;}
  #canvas-wrap{width:100%;max-width:1100px;flex:1;display:flex;align-items:center;justify-content:center;}
  canvas{width:100%;height:100%;max-height:75vh;border-radius:10px;background:#2b7a2b;display:block;touch-action:none;}
  /* Mobile floating controls */
  .touch-controls{position:fixed;bottom:20px;left:0;right:0;pointer-events:none;display:flex;justify-content:space-between;padding:0 16px;}
  .control-zone{pointer-events:auto;display:flex;gap:10px;align-items:center;}
  .btn{width:68px;height:68px;border-radius:14px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;font-weight:700;color:#fff;font-size:20px;user-select:none;touch-action:none;border:1px solid rgba(255,255,255,0.04);}
  .small{width:50px;height:50px;border-radius:12px;font-size:18px;}
  .invisible{opacity:0.001}
  /* Layout helper for desktop controls overlay (hidden on mobile) */
  #debug{margin-left:8px;font-size:13px;color:#ddd;opacity:0.9;}
  @media(min-width:900px){
    .touch-controls{display:none;}
    canvas{max-height:70vh;}
  }
  @media(max-width:899px){
    #ui-row{padding:0 6px;}
    .panel{padding:6px 8px;}
    :root{--ui-size:12px;}
  }
</style>
</head>
<body>
<div id="game-wrap">
  <div id="ui-row">
    <div class="panel" id="hud">
      <div id="speedo">SPEED: 0</div>
      <div id="timer">TIME: 00:00.000</div>
      <div id="laps">DIST: 0m</div>
    </div>
    <div class="panel" id="debug">Use W/A/S/D or touch controls. Tap Gas to accelerate, Brake to reverse.</div>
  </div>

  <div id="canvas-wrap" class="panel">
    <canvas id="game" width="1100" height="700"></canvas>
  </div>
</div>

<!-- Mobile floating controls -->
<div class="touch-controls" aria-hidden="true">
  <div class="control-zone">
    <div class="btn small" id="left-btn">◀</div>
    <div class="btn small" id="right-btn">▶</div>
  </div>
  <div class="control-zone">
    <div class="btn" id="gas-btn">▲</div>
    <div class="btn" id="brake-btn">▼</div>
  </div>
</div>

<script>
/* ========== Config ========== */
const CONFIG = {
  maxSpeed: 6.4,         // pixels per frame base
  accel: 0.18,           // acceleration per tick
  brakeAccel: 0.24,      // braking / reverse accel
  friction: 0.985,       // global speed decay (1 = no friction)
  steerSpeed: 0.04,       // base steering sensitivity
  driftFactor: 0.85,      // lateral velocity damping when sliding
  width: 1100,
  height: 700,
  meterPerPixel: 0.4     // simple conversion for "meters"
};

/* ========== Utilities ========== */
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function now(){return performance.now();}

/* ========== Track & Obstacles (simple vector track) ========== */
class Track {
  constructor(w,h){
    this.w = w; this.h = h;
    // generate a simple road path as an array of segments (for collisions and rendering)
    this.road = []; // polygon outer ring and inner ring approximated by rectangles/curves
    this.obstacles = [];
    this.generate();
  }
  generate(){
    // For demo: draw a curvy loop using simple bezier-ish segments.
    // We'll build a path by sampling a parametric circle distorted.
    const cx = this.w/2, cy = this.h/2;
    const radius = Math.min(this.w,this.h)/2 - 80;
    this.centerPath = [];
    const points = 120;
    for(let i=0;i<points;i++){
      const a = (i/points)*Math.PI*2;
      const r = radius * (1 + 0.12*Math.sin(a*3)+0.06*Math.cos(a*5));
      this.centerPath.push({x:cx+Math.cos(a)*r, y:cy+Math.sin(a)*r});
    }
    // create obstacles at some points
    for(let i=0;i<12;i++){
      const p = this.centerPath[Math.floor(Math.random()*this.centerPath.length)];
      const ox = p.x + (Math.random()*300-150);
      const oy = p.y + (Math.random()*200-100);
      this.obstacles.push({x:ox,y:oy,r:16,type:'cone'});
    }
    // Add some fixed obstacles near start line
    this.obstacles.push({x:cx+120,y:cy-40,r:20,type:'rock'});
    this.obstacles.push({x:cx-200,y:cy+80,r:22,type:'barrier'});
  }
  draw(ctx,cam){
    // fill grass
    ctx.fillStyle='#225f22';
    ctx.fillRect(0,0,this.w,this.h);

    // draw road by stroking the center path as thick gray ribbon
    ctx.save();
    ctx.translate(-cam.x + cam.viewW/2, -cam.y + cam.viewH/2);
    // smooth path
    ctx.lineJoin='round';
    ctx.lineCap='round';
    // draw road as thick line (two strokes: base + edges)
    ctx.strokeStyle='#666';
    ctx.lineWidth=180; // road width
    ctx.beginPath();
    for(let i=0;i<this.centerPath.length;i++){
      const p=this.centerPath[i];
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.closePath();
    ctx.stroke();

    // draw road centerline dashed
    ctx.strokeStyle='rgba(255,255,255,0.18)';
    ctx.lineWidth=3;
    ctx.setLineDash([18,18]);
    ctx.beginPath();
    for(let i=0;i<this.centerPath.length;i++){
      const p=this.centerPath[i];
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.setLineDash([]);

    // obstacles
    for(const o of this.obstacles){
      ctx.beginPath();
      if(o.type==='cone'){
        ctx.fillStyle='#ff6b00';
        ctx.moveTo(o.x, o.y - o.r);
        ctx.lineTo(o.x + o.r, o.y + o.r);
        ctx.lineTo(o.x - o.r, o.y + o.r);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.fillStyle='#3a3a3a';
        ctx.fillRect(o.x - o.r, o.y - o.r, o.r*2, o.r*2);
      }
    }

    // start/finish marker
    const s = this.centerPath[0];
    ctx.fillStyle='rgba(255,255,0,0.95)';
    ctx.fillRect(s.x-120, s.y-12, 240, 8);

    ctx.restore();
  }
}

/* ========== Car ========== */
class Car {
  constructor(x,y){
    this.x = x; this.y = y;
    this.width = 48; this.height = 28;
    this.angle = -Math.PI/2; // facing up
    this.speed = 0;
    this.velX = 0; this.velY = 0;
    this.lastLapPos = {x,y};
    this.color = '#e83';
    this.shadowOffset = 8;
  }
  update(input,dt){
    // dt ~= time step fraction (not used heavily here). Use fixed-step-ish physics.
    // Input: throttle (-1 to 1), steer (-1 to 1)
    const throttle = input.throttle; // -1 to +1
    const steer = input.steer; // -1 left, +1 right
    // Apply acceleration/brake
    if(throttle > 0.001){
      this.speed += CONFIG.accel * throttle;
    } else if(throttle < -0.001){
      this.speed += CONFIG.brakeAccel * throttle; // negative
    } else {
      // natural slowdown via friction below
    }

    // limit speed (reverse lower)
    const maxF = CONFIG.maxSpeed;
    const maxR = -CONFIG.maxSpeed * 0.5;
    this.speed = clamp(this.speed, maxR, maxF);

    // Steering scaled by speed magnitude (low speed -> low steering
