
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Spike Arena</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #0d1117; /* Dark background */
            font-family: 'Arial', sans-serif;
            color: #ffffff;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* Neon glow effect */
            border: 2px solid #00ffff;
        }

        #game {
            display: block;
            background-color: #161b22; /* Darker inner background */
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            text-align: center;
            pointer-events: none; /* Allows clicks to fall through unless game over */
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #ui-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        #game-message {
            font-size: 4em;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ffff;
            color: #00ffff;
        }

        #restart-button {
            padding: 15px 30px;
            font-size: 1.5em;
            cursor: pointer;
            background-color: #00ffff;
            color: #161b22;
            border: none;
            border-radius: 5px;
            box-shadow: 0 0 15px #00ffff;
            transition: background-color 0.2s, box-shadow 0.2s;
        }

        #restart-button:hover {
            background-color: #00e0e0;
            box-shadow: 0 0 20px #00ffff, 0 0 5px #00e0e0;
        }

        #score-board {
            margin-top: 10px;
            font-size: 1.2em;
            width: 500px;
            display: flex;
            justify-content: space-around;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
        }

        .status-box {
            padding: 5px 10px;
            border: 1px solid #333;
            border-radius: 3px;
            background-color: #1f2730;
        }

    </style>
</head>
<body>

    <div id="score-board">
        <div class="status-box">Time Survived: <span id="time-display">0.00</span>s</div>
        <div class="status-box">High Score: <span id="high-score-display">0.00</span>s</div>
        <div class="status-box">Player Status: <span id="player-status-display" style="color: lime;">ALIVE</span></div>
        <div class="status-box">Bot Status: <span id="bot-status-display" style="color: lime;">ALIVE</span></div>
    </div>

    <div id="game-container">
        <canvas id="game" width="500" height="500"></canvas>
        <div id="ui-overlay">
            <div id="game-message">SPIKE ARENA</div>
            <button id="restart-button">Start Game</button>
        </div>
    </div>

    <script>
        // === Configuration and Constants ===
        const CANVAS = document.getElementById('game');
        const CTX = CANVAS.getContext('2d');
        const WIDTH = CANVAS.width;
        const HEIGHT = CANVAS.height;
        const PLAYER_SIZE = 20;
        const BOT_SIZE = 20;
        const OBSTACLE_SIZE = 40;
        const INITIAL_SPEED = 3;
        const MAX_SPIKE_LENGTH = 150;
        const SPIKE_WARNING_TIME_MS = 1500;
        const SPIKE_GROWTH_SPEED_PX_PER_MS = 0.2;
        const MAX_OBSTACLES = 5;
        const OBSTACLE_COLOR = '#3b434b';

        // === Game State Variables ===
        let gameState = {
            running: false,
            gameOver: true,
            startTime: 0,
            elapsedTime: 0,
            highScore: parseFloat(localStorage.getItem('spikeArenaHighScore') || 0),
            player: { x: WIDTH / 2 - PLAYER_SIZE / 2, y: HEIGHT / 2 - PLAYER_SIZE / 2, dx: 0, dy: 0, size: PLAYER_SIZE, alive: true, color: '#00ffff' },
            bot: { x: WIDTH / 2 - BOT_SIZE / 2 + 50, y: HEIGHT / 2 - BOT_SIZE / 2, dx: 0, dy: 0, size: BOT_SIZE, alive: true, color: '#ff00ff', targetX: 0, targetY: 0 },
            keys: {},
            spike: {
                activeSide: null, // 'top', 'right', 'bottom', 'left'
                warningTimer: 0,
                growth: 0, // current length
                maxWarning: SPIKE_WARNING_TIME_MS,
                growthSpeed: SPIKE_GROWTH_SPEED_PX_PER_MS,
                isWarning: false
            },
            obstacles: [],
            lastFrameTime: 0,
            frameId: null
        };

        // === DOM Elements ===
        const UI_OVERLAY = document.getElementById('ui-overlay');
        const RESTART_BUTTON = document.getElementById('restart-button');
        const GAME_MESSAGE = document.getElementById('game-message');
        const TIME_DISPLAY = document.getElementById('time-display');
        const HIGH_SCORE_DISPLAY = document.getElementById('high-score-display');
        const PLAYER_STATUS = document.getElementById('player-status-display');
        const BOT_STATUS = document.getElementById('bot-status-display');

        HIGH_SCORE_DISPLAY.textContent = gameState.highScore.toFixed(2);

        // === Utility Functions ===

        /**
         * Generates a random number within the canvas bounds, respecting size.
         * @param {number} size - The width/height of the object.
         * @returns {number} The coordinate.
         */
        function getRandomCoord(size) {
            return Math.random() * (WIDTH - size);
        }

        /**
         * Checks for AABB collision between two rectangles.
         * @param {object} r1 - Rectangle 1 {x, y, w, h}
         * @param {object} r2 - Rectangle 2 {x, y, w, h}
         * @returns {boolean} True if they overlap.
         */
        function checkCollision(r1, r2) {
            return r1.x < r2.x + r2.w &&
                   r1.x + r1.w > r2.x &&
                   r1.y < r2.y + r2.h &&
                   r1.y + r1.h > r2.y;
        }

        /**
         * Checks for collision between an object (player/bot) and the obstacles.
         * @param {object} object - The moving object {x, y, size}
         * @param {number} newX - The potential new X position.
         * @param {number} newY - The potential new Y position.
         * @returns {boolean} True if the move results in a collision.
         */
        function checkObstacleCollision(object, newX, newY) {
            const tempRect = { x: newX, y: newY, w: object.size, h: object.size };
            for (const obs of gameState.obstacles) {
                const obsRect = { x: obs.x, y: obs.y, w: OBSTACLE_SIZE, h: OBSTACLE_SIZE };
                if (checkCollision(tempRect, obsRect)) {
                    return true;
                }
            }
            return false;
        }

        // === Game Logic Functions ===

        /**
         * Initializes or resets the game state.
         */
        function resetGame() {
            gameState.running = false;
            gameState.gameOver = false;
            gameState.startTime = Date.now();
            gameState.elapsedTime = 0;
            gameState.player.alive = true;
            gameState.bot.alive = true;
            gameState.player.x = WIDTH / 2 - PLAYER_SIZE / 2;
            gameState.player.y = HEIGHT / 2 - PLAYER_SIZE / 2;
            gameState.bot.x = WIDTH / 2 - BOT_SIZE / 2 + 80;
            gameState.bot.y = HEIGHT / 2 - BOT_SIZE / 2 + 80;
            gameState.player.dx = 0;
            gameState.player.dy = 0;
            gameState.bot.dx = 0;
            gameState.bot.dy = 0;
            gameState.obstacles = [];
            gameState.spike.activeSide = null;
            gameState.spike.warningTimer = 0;
            gameState.spike.growth = 0;
            gameState.spike.isWarning = false;

            // Spawn initial obstacles
            spawnObstacles(3);

            // Update UI status
            PLAYER_STATUS.textContent = 'ALIVE';
            PLAYER_STATUS.style.color = 'lime';
            BOT_STATUS.textContent = 'ALIVE';
            BOT_STATUS.style.color = 'lime';
            TIME_DISPLAY.textContent = '0.00';

            // Hide the UI overlay
            UI_OVERLAY.classList.remove('active');
            
            if (gameState.frameId) {
                cancelAnimationFrame(gameState.frameId);
            }
            gameState.lastFrameTime = performance.now();
            gameState.running = true;
            gameState.frameId = requestAnimationFrame(gameLoop);
        }

        /**
         * Handles player movement based on keyboard input.
         * @param {number} deltaTime - Time elapsed since last frame (in seconds).
         */
        function handleInput(deltaTime) {
            if (!gameState.player.alive) return;

            gameState.player.dx = 0;
            gameState.player.dy = 0;
            const speed = INITIAL_SPEED;

            if (gameState.keys['w']) gameState.player.dy -= speed;
            if (gameState.keys['s']) gameState.player.dy += speed;
            if (gameState.keys['a']) gameState.player.dx -= speed;
            if (gameState.keys['d']) gameState.player.dx += speed;

            // Normalize diagonal movement speed
            if (gameState.player.dx !== 0 && gameState.player.dy !== 0) {
                const factor = 1 / Math.sqrt(2);
                gameState.player.dx *= factor;
                gameState.player.dy *= factor;
            }

            // Calculate potential new position
            let newX = gameState.player.x + gameState.player.dx;
            let newY = gameState.player.y + gameState.player.dy;

            // Clamp position to stay within arena bounds
            newX = Math.max(0, Math.min(newX, WIDTH - PLAYER_SIZE));
            newY = Math.max(0, Math.min(newY, HEIGHT - PLAYER_SIZE));

            // Check collision and update position
            if (!checkObstacleCollision(gameState.player, newX, gameState.player.y)) {
                gameState.player.x = newX;
            }
            if (!checkObstacleCollision(gameState.player, gameState.player.x, newY)) {
                gameState.player.y = newY;
            }
        }

        /**
         * Bot AI logic for movement and evasion.
         * @param {number} deltaTime - Time elapsed since last frame (in seconds).
         */
        function botAI(deltaTime) {
            const bot = gameState.bot;
            if (!bot.alive) return;

            const speed = INITIAL_SPEED * 0.9; // Bot is slightly slower

            // 1. Evasion Logic (High Priority)
            if (gameState.spike.isWarning || gameState.spike.growth > 0) {
                const side = gameState.spike.activeSide;
                const buffer = 50; // Distance to maintain from the edge

                let evadeDx = 0;
                let evadeDy = 0;

                switch (side) {
                    case 'top':
                        if (bot.y < MAX_SPIKE_LENGTH) evadeDy = speed;
                        break;
                    case 'bottom':
                        if (bot.y + bot.size > HEIGHT - MAX_SPIKE_LENGTH) evadeDy = -speed;
                        break;
                    case 'left':
                        if (bot.x < MAX_SPIKE_LENGTH) evadeDx = speed;
                        break;
                    case 'right':
                        if (bot.x + bot.size > WIDTH - MAX_SPIKE_LENGTH) evadeDx = -speed;
                        break;
                }

                if (evadeDx !== 0 || evadeDy !== 0) {
                    bot.dx = evadeDx;
                    bot.dy = evadeDy;
                } else {
                    // If safe but a spike is active, just wander
                    wander(bot, speed);
                }

            } else {
                // 2. Wandering Logic (Low Priority)
                if (Math.random() < 0.01) { // Change target 1% of the time
                    wander(bot, speed);
                }

                // Move towards target
                const dx = bot.targetX - (bot.x + bot.size / 2);
                const dy = bot.targetY - (bot.y + bot.size / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 5) {
                    bot.dx = (dx / dist) * speed;
                    bot.dy = (dy / dist) * speed;
                } else {
                    bot.dx = 0;
                    bot.dy = 0;
                }
            }

            // Normalize diagonal movement speed
            if (bot.dx !== 0 && bot.dy !== 0) {
                const factor = 1 / Math.sqrt(2);
                bot.dx *= factor;
                bot.dy *= factor;
            }

            // Update bot position
            let newX = bot.x + bot.dx;
            let newY = bot.y + bot.dy;

            // Clamp position to stay within arena bounds
            newX = Math.max(0, Math.min(newX, WIDTH - BOT_SIZE));
            newY = Math.max(0, Math.min(newY, HEIGHT - BOT_SIZE));

            // Check collision and update position
            if (!checkObstacleCollision(bot, newX, bot.y)) {
                bot.x = newX;
            } else {
                // Try moving only vertically if horizontal blocked
                if (!checkObstacleCollision(bot, bot.x, newY)) {
                    bot.x = bot.x; // Blocked horizontal movement
                } else {
                    // Completely blocked, force a new target
                    wander(bot, speed);
                }
            }
            if (!checkObstacleCollision(bot, bot.x, newY)) {
                bot.y = newY;
            } else {
                 // Try moving only horizontally if vertical blocked
                if (!checkObstacleCollision(bot, newX, bot.y)) {
                    bot.y = bot.y; // Blocked vertical movement
                } else {
                    // Completely blocked, force a new target
                    wander(bot, speed);
                }
            }

            // Final position update after collision checks
            bot.x = newX;
            bot.y = newY;
        }

        /**
         * Sets a new random target for the bot to move to.
         * @param {object} bot - The bot object.
         * @param {number} speed - The speed of the bot.
         */
        function wander(bot, speed) {
            bot.targetX = Math.random() * (WIDTH - bot.size) + bot.size / 2;
            bot.targetY = Math.random() * (HEIGHT - bot.size) + bot.size / 2;
        }


        /**
         * Manages the spike activation, growth, and difficulty scaling.
         * @param {number} deltaTimeMs - Time elapsed since last frame (in milliseconds).
         */
        function updateSpikes(deltaTimeMs) {
            const spike = gameState.spike;
            const timeSeconds = gameState.elapsedTime;

            // Difficulty Scaling
            // Warning time decreases from 1500ms down to 500ms over 60 seconds
            spike.maxWarning = Math.max(500, SPIKE_WARNING_TIME_MS - timeSeconds * 16.6); // ~1000ms reduction over 60s

            // Growth speed increases from 0.2 up to 0.6 over 90 seconds
            spike.growthSpeed = SPIKE_GROWTH_SPEED_PX_PER_MS + (timeSeconds / 90) * 0.4;
            spike.growthSpeed = Math.min(0.6, spike.growthSpeed);

            // Spawn new obstacles every 15 seconds
            if (timeSeconds > 0 && Math.floor(timeSeconds) % 15 === 0 && Math.floor(timeSeconds) !== Math.floor(gameState.elapsedTime - deltaTimeMs/1000)) {
                spawnObstacles(1);
            }

            if (spike.activeSide === null) {
                // Not active: Set new warning timer
                spike.activeSide = ['top', 'right', 'bottom', 'left'][Math.floor(Math.random() * 4)];
                spike.isWarning = true;
                spike.warningTimer = spike.maxWarning;
                spike.growth = 0;
            } else if (spike.isWarning) {
                // Warning phase
                spike.warningTimer -= deltaTimeMs;
                if (spike.warningTimer <= 0) {
                    // Transition to growth
                    spike.isWarning = false;
                }
            } else {
                // Growth phase
                spike.growth += spike.growthSpeed * deltaTimeMs;

                if (spike.growth >= MAX_SPIKE_LENGTH) {
                    // Reset spike after max length reached
                    spike.activeSide = null;
                }
            }
        }

        /**
         * Spawns a given number of obstacles in non-colliding locations.
         * @param {number} count - The number of obstacles to spawn.
         */
        function spawnObstacles(count) {
            let attempts = 0;
            let currentCount = gameState.obstacles.length;
            const max = MAX_OBSTACLES;
            
            while (count > 0 && currentCount < max && attempts < 100) {
                const newObs = { x: getRandomCoord(OBSTACLE_SIZE), y: getRandomCoord(OBSTACLE_SIZE), w: OBSTACLE_SIZE, h: OBSTACLE_SIZE };
                const newObsRect = { x: newObs.x, y: newObs.y, w: OBSTACLE_SIZE, h: OBSTACLE_SIZE };
                let collisionFound = false;

                // Check collision against existing obstacles
                for (const obs of gameState.obstacles) {
                    const obsRect = { x: obs.x, y: obs.y, w: OBSTACLE_SIZE, h: OBSTACLE_SIZE };
                    if (checkCollision(newObsRect, obsRect)) {
                        collisionFound = true;
                        break;
                    }
                }

                // Check collision against player/bot start positions (center area)
                const centerArea = { x: WIDTH/2 - 100, y: HEIGHT/2 - 100, w: 200, h: 200 };
                 if (checkCollision(newObsRect, centerArea)) {
                    collisionFound = true;
                }


                if (!collisionFound) {
                    gameState.obstacles.push(newObs);
                    count--;
                    currentCount++;
                }
                attempts++;
            }
        }


        /**
         * Checks if the player or bot has been hit by the active spike.
         */
        function checkSpikeCollision() {
            const spike = gameState.spike;
            if (spike.growth <= 0) return;

            // Define the spike hitbox based on the active side and current growth
            let spikeRect = { x: 0, y: 0, w: WIDTH, h: HEIGHT };
            const length = spike.growth;

            switch (spike.activeSide) {
                case 'top':
                    spikeRect = { x: 0, y: 0, w: WIDTH, h: length };
                    break;
                case 'bottom':
                    spikeRect = { x: 0, y: HEIGHT - length, w: WIDTH, h: length };
                    break;
                case 'left':
                    spikeRect = { x: 0, y: 0, w: length, h: HEIGHT };
                    break;
                case 'right':
                    spikeRect = { x: WIDTH - length, y: 0, w: length, h: HEIGHT };
                    break;
            }

            // Check Player Collision
            if (gameState.player.alive) {
                const playerRect = { x: gameState.player.x, y: gameState.player.y, w: PLAYER_SIZE, h: PLAYER_SIZE };
                if (checkCollision(playerRect, spikeRect)) {
                    gameState.player.alive = false;
                    PLAYER_STATUS.textContent = 'DEAD';
                    PLAYER_STATUS.style.color = 'red';
                }
            }

            // Check Bot Collision
            if (gameState.bot.alive) {
                const botRect = { x: gameState.bot.x, y: gameState.bot.y, w: BOT_SIZE, h: BOT_SIZE };
                if (checkCollision(botRect, spikeRect)) {
                    gameState.bot.alive = false;
                    BOT_STATUS.textContent = 'DEAD';
                    BOT_STATUS.style.color = 'red';
                }
            }

            // Check for game over condition
            if (!gameState.player.alive && gameState.running) {
                // Give a small moment for the bot to survive longer
                if (gameState.bot.alive) {
                    // Bot is still alive, game continues until bot dies
                } else {
                    endGame();
                }
            }
            if (!gameState.bot.alive && !gameState.player.alive && gameState.running) {
                endGame();
            }
        }

        /**
         * Ends the game and displays the results.
         */
        function endGame() {
            gameState.running = false;
            gameState.gameOver = true;

            const timeSurvived = gameState.elapsedTime;
            let message = '';

            if (gameState.player.alive) {
                message = 'ERROR: GAME SHOULD NOT END WHILE PLAYER IS ALIVE';
            } else if (gameState.bot.alive) {
                message = 'DEFEAT!'; // Bot survived longer
                BOT_STATUS.style.color = 'gold';
            } else if (gameState.elapsedTime > gameState.botStartTime) {
                message = 'VICTORY!'; // Player survived longer
                PLAYER_STATUS.style.color = 'gold';
            } else {
                message = 'GAME OVER!'; // Both died simultaneously or close
            }


            // Update High Score
            if (timeSurvived > gameState.highScore) {
                gameState.highScore = timeSurvived;
                localStorage.setItem('spikeArenaHighScore', timeSurvived.toFixed(2));
                HIGH_SCORE_DISPLAY.textContent = timeSurvived.toFixed(2);
            }

            // Show UI overlay
            GAME_MESSAGE.textContent = message;
            RESTART_BUTTON.textContent = 'Restart Game';
            UI_OVERLAY.classList.add('active');
        }

        /**
         * Main game update loop.
         * @param {number} currentTime - High resolution timestamp.
         */
        function update(currentTime) {
            if (!gameState.running) return;

            const deltaTimeMs = currentTime - gameState.lastFrameTime;
            gameState.lastFrameTime = currentTime;
            const deltaTime = deltaTimeMs / 1000; // Delta time in seconds

            if (gameState.player.alive || gameState.bot.alive) {
                gameState.elapsedTime += deltaTime;
            }

            // Update Time Display
            TIME_DISPLAY.textContent = gameState.elapsedTime.toFixed(2);

            // Update entities if alive
            handleInput(deltaTime);
            botAI(deltaTime);

            // Update Spikes and Difficulty
            updateSpikes(deltaTimeMs);

            // Check for death
            checkSpikeCollision();

            // If only one is alive, check if the survivor is the player
            if (!gameState.player.alive && gameState.bot.alive) {
                 // The player is dead, but the bot is still alive. The game continues
                 // until the bot dies. If the bot survives to the next spike and dies
                 // the game ends.
            } else if (!gameState.player.alive && !gameState.bot.alive) {
                // Both are dead
                endGame();
            }

        }

        // === Rendering Functions ===

        /**
         * Draws a single spike rectangle.
         * @param {string} side - 'top', 'right', 'bottom', 'left'
         * @param {number} length - Current growth length.
         * @param {string} color - The color to draw the spike.
         */
        function drawSpike(side, length, color) {
            CTX.fillStyle = color;
            switch (side) {
                case 'top':
                    CTX.fillRect(0, 0, WIDTH, length);
                    break;
                case 'right':
                    CTX.fillRect(WIDTH - length, 0, length, HEIGHT);
                    break;
                case 'bottom':
                    CTX.fillRect(0, HEIGHT - length, WIDTH, length);
                    break;
                case 'left':
                    CTX.fillRect(0, 0, length, HEIGHT);
                    break;
            }
        }

        /**
         * Main drawing function.
         */
        function draw() {
            // Clear the canvas
            CTX.clearRect(0, 0, WIDTH, HEIGHT);

            // Draw Obstacles
            CTX.fillStyle = OBSTACLE_COLOR;
            for (const obs of gameState.obstacles) {
                CTX.fillRect(obs.x, obs.y, OBSTACLE_SIZE, OBSTACLE_SIZE);
            }

            // Draw Spike
            const spike = gameState.spike;
            if (spike.activeSide) {
                let color = spike.isWarning ? '#ffcc00' : '#ff3333'; // Yellow warning, Red spike

                // Blinking effect for warning
                if (spike.isWarning && Math.floor(gameState.elapsedTime * 10) % 2) {
                    // Blink on
                    drawSpike(spike.activeSide, 10, color); // Draw a small blinking bar
                } else if (!spike.isWarning) {
                    // Draw full growing spike
                    drawSpike(spike.activeSide, spike.growth, color);
                }
            }

            // Draw Player
            if (gameState.player.alive) {
                CTX.fillStyle = gameState.player.color;
                CTX.shadowBlur = 10;
                CTX.shadowColor = gameState.player.color;
                CTX.fillRect(gameState.player.x, gameState.player.y, PLAYER_SIZE, PLAYER_SIZE);
                CTX.shadowBlur = 0; // Reset shadow for other objects
            } else if (gameState.running) {
                // Draw a small tombstone or faded square
                CTX.fillStyle = 'rgba(0, 255, 255, 0.2)';
                CTX.fillRect(gameState.player.x, gameState.player.y, PLAYER_SIZE, PLAYER_SIZE);
            }

            // Draw Bot
            if (gameState.bot.alive) {
                CTX.fillStyle = gameState.bot.color;
                CTX.shadowBlur = 10;
                CTX.shadowColor = gameState.bot.color;
                CTX.fillRect(gameState.bot.x, gameState.bot.y, BOT_SIZE, BOT_SIZE);
                CTX.shadowBlur = 0; // Reset shadow for other objects
            } else if (gameState.running) {
                // Draw a small tombstone or faded square
                CTX.fillStyle = 'rgba(255, 0, 255, 0.2)';
                CTX.fillRect(gameState.bot.x, gameState.bot.y, BOT_SIZE, BOT_SIZE);
            }
        }

        // === Game Loop ===
        function gameLoop(currentTime) {
            update(currentTime);
            draw();

            if (gameState.running) {
                gameState.frameId = requestAnimationFrame(gameLoop);
            }
        }

        // === Event Listeners ===
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });

        RESTART_BUTTON.addEventListener('click', resetGame);

        // Initial setup to display the start screen
        UI_OVERLAY.classList.add('active');
        draw(); // Draw the initial arena/canvas

    </script>
</body>
</html>

