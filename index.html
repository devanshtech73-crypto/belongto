<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Spike Arena - Mobile</title>
    <!-- Critical for mobile: locks viewport, prevents scaling/zooming -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        :root {
            --color-bg-dark: #000408;
            --color-arena-dark: #08101a;
            --color-neon-blue: #00e5ff;
            --color-neon-magenta: #ff00ff;
            --color-neon-red: #ff3333;
            --color-steel: #2e3547;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--color-bg-dark);
            font-family: 'Orbitron', sans-serif;
            color: var(--color-neon-blue);
            overflow: hidden; /* Prevent body scroll */
            /* Prevent scrolling/zooming on mobile */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none; /* Disable all default touch actions */
        }

        #game-container {
            position: relative;
            margin: 20px 0;
            width: 90vw;
            max-width: 500px;
            height: 90vw;
            max-height: 500px;
            box-shadow: 0 0 30px var(--color-neon-blue), 0 0 15px var(--color-neon-magenta) inset;
            border: 3px solid var(--color-neon-blue);
            border-radius: 10px;
            overflow: hidden;
            touch-action: none;
        }

        #game {
            display: block;
            background-color: var(--color-arena-dark);
            width: 100%;
            height: 100%;
        }

        /* === UI Overlay and Messages === */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.4s ease-in-out;
            z-index: 10;
        }

        #ui-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        #game-message {
            font-size: 10vw;
            font-weight: 700;
            margin-bottom: 30px;
            text-shadow: 0 0 15px var(--color-neon-blue);
            color: var(--color-neon-blue);
            animation: pulse-neon 1.5s infinite alternate;
        }

        @keyframes pulse-neon {
            from {
                text-shadow: 0 0 5px var(--color-neon-blue), 0 0 10px var(--color-neon-blue);
            }
            to {
                text-shadow: 0 0 20px var(--color-neon-blue), 0 0 40px var(--color-neon-magenta);
            }
        }

        #restart-button {
            padding: 15px 40px;
            font-size: 5vw;
            font-weight: bold;
            cursor: pointer;
            background-color: var(--color-neon-magenta);
            color: var(--color-bg-dark);
            border: none;
            border-radius: 5px;
            box-shadow: 0 0 15px var(--color-neon-magenta);
            transition: all 0.2s ease;
        }

        #restart-button:active {
            background-color: var(--color-neon-blue);
            box-shadow: 0 0 20px var(--color-neon-blue);
            transform: scale(0.95);
        }

        /* === Scoreboard === */
        #score-board {
            width: 90vw;
            max-width: 500px;
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
            font-size: 3vw;
        }

        .status-box {
            padding: 5px 10px;
            margin: 5px;
            border: 1px solid var(--color-steel);
            border-radius: 5px;
            background-color: var(--color-arena-dark);
            transition: all 0.3s;
        }

        /* === Joystick Styles === */
        #joystick-container {
            position: fixed;
            bottom: 20px;
            left: 5vw;
            width: 150px;
            height: 150px;
            z-index: 20;
            opacity: 0.9;
        }

        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(46, 53, 71, 0.5); /* Semi-transparent steel */
            border-radius: 50%;
            border: 2px solid var(--color-neon-blue);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5) inset;
        }

        .joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            background: var(--color-neon-magenta);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
            box-shadow: 0 0 20px var(--color-neon-magenta);
            transition: background 0.1s, box-shadow 0.1s;
        }
    </style>
</head>
<body>

    <div id="score-board">
        <div class="status-box">TIME: <span id="time-display">0.00</span>s</div>
        <div class="status-box">HI-SCORE: <span id="high-score-display">0.00</span>s</div>
        <div class="status-box">PLAYER: <span id="player-status-display" style="color: var(--color-neon-blue);">READY</span></div>
        <div class="status-box">BOT: <span id="bot-status-display" style="color: var(--color-neon-magenta);">READY</span></div>
    </div>

    <div id="game-container">
        <canvas id="game" width="500" height="500"></canvas>
        <div id="ui-overlay">
            <div id="game-message">SPIKE ARENA</div>
            <button id="restart-button">START SIMULATION</button>
        </div>
        
        <!-- Joystick Implementation (Fixed position for mobile) -->
        <div id="joystick-container">
            <div class="joystick-base"></div>
            <div id="joystick-handle" class="joystick-handle"></div>
        </div>
    </div>

    <script>
        // === Configuration and Constants ===
        const CANVAS = document.getElementById('game');
        const CTX = CANVAS.getContext('2d');
        // Canvas is resized to fill container using CSS, but internal logic uses fixed 500x500 for calculation ease
        const WIDTH = 500; 
        const HEIGHT = 500;
        const PLAYER_SIZE = 25;
        const BOT_SIZE = 25;
        const OBSTACLE_SIZE = 40;
        const MAX_SPEED = 3.5; // Increased speed for mobile responsiveness
        const BOT_WANDER_SPEED = MAX_SPEED; 
        const MAX_SPIKE_LENGTH = 500; 
        const SEGMENTS = 5; 
        const SEGMENT_GAP = 4;
        const TIP_SIZE = 15; 
        const FIXED_SPIKE_WARNING_TIME_MS = 1500; // Shorter warning time for faster pace
        const INITIAL_SPIKE_GROWTH_SPEED_PX_PER_MS = 0.5; // High base speed
        const MAX_OBSTACLES = 3; 
        const OBSTACLE_COLOR = 'var(--color-steel)';
        
        // Neon color variables
        const SPIKE_COLOR = '#ff9900'; 
        const WARNING_COLOR_RED = 'var(--color-neon-red)';
        const PLAYER_COLOR = 'var(--color-neon-blue)';
        const BOT_COLOR = 'var(--color-neon-magenta)';

        // === Game State Variables ===
        let gameState = {
            running: false,
            gameOver: true,
            startTime: 0,
            elapsedTime: 0,
            highScore: parseFloat(localStorage.getItem('spikeArenaHighScore') || 0),
            player: { x: WIDTH / 2 - PLAYER_SIZE / 2, y: HEIGHT / 2 - PLAYER_SIZE / 2, dx: 0, dy: 0, size: PLAYER_SIZE, alive: true, color: PLAYER_COLOR },
            bot: { x: WIDTH / 2 - BOT_SIZE / 2 + 80, y: HEIGHT / 2 - BOT_SIZE / 2 + 80, dx: 0, dy: 0, size: BOT_SIZE, alive: true, color: BOT_COLOR, targetX: 0, targetY: 0, stuckTimer: 0 },
            keys: {}, // Keeping for minimal keyboard support if used on hybrid device
            joystick: { dx: 0, dy: 0 }, 
            spike: {
                activeSide: null, 
                warningTimer: 0,
                growth: 0, 
                maxWarning: FIXED_SPIKE_WARNING_TIME_MS,
                growthSpeed: INITIAL_SPIKE_GROWTH_SPEED_PX_PER_MS,
                isWarning: false,
                segmentBlockLengths: new Array(SEGMENTS).fill(MAX_SPIKE_LENGTH), 
                durationTimer: 0,
                maxDuration: 0,   
            },
            obstacles: [],
            lastFrameTime: 0,
            frameId: null
        };

        // === DOM Elements ===
        const UI_OVERLAY = document.getElementById('ui-overlay');
        const RESTART_BUTTON = document.getElementById('restart-button');
        const GAME_MESSAGE = document.getElementById('game-message');
        const TIME_DISPLAY = document.getElementById('time-display');
        const HIGH_SCORE_DISPLAY = document.getElementById('high-score-display');
        const PLAYER_STATUS = document.getElementById('player-status-display');
        const BOT_STATUS = document.getElementById('bot-status-display');
        
        const JOYSTICK_CONTAINER = document.getElementById('joystick-container');
        const JOYSTICK_HANDLE = document.getElementById('joystick-handle');
        const JOYSTICK_SIZE = 150;
        const JOYSTICK_CENTER = JOYSTICK_SIZE / 2;
        const HANDLE_SIZE = parseInt(getComputedStyle(JOYSTICK_HANDLE).width);
        const MAX_JOYSTICK_DISTANCE = (JOYSTICK_SIZE / 2) - (HANDLE_SIZE / 2);

        HIGH_SCORE_DISPLAY.textContent = gameState.highScore.toFixed(2);
        
        // Initial setup for status colors
        PLAYER_STATUS.style.color = PLAYER_COLOR;
        BOT_STATUS.style.color = BOT_COLOR;

        // === Utility Functions ===

        function getRandomCoord(size) {
            return Math.random() * (WIDTH - size);
        }

        function checkCollision(r1, r2) {
            return r1.x < r2.x + r2.w &&
                   r1.x + r1.w > r2.x &&
                   r1.y < r2.y + r2.h &&
                   r1.y + r1.h > r2.y;
        }

        function checkObstacleCollision(object, newX, newY) {
            const tempRect = { x: newX, y: newY, w: object.size, h: object.size };
            for (const obs of gameState.obstacles) {
                const obsRect = { x: obs.x, y: obs.y, w: OBSTACLE_SIZE, h: OBSTACLE_SIZE };
                if (checkCollision(tempRect, obsRect)) {
                    return true;
                }
            }
            return false;
        }
        
        function handlePlayerBotCollision() {
            if (!gameState.player.alive || !gameState.bot.alive) return;
            // Simplified collision check: prevent overlap but don't apply full physics
            const player = gameState.player;
            const bot = gameState.bot;
            
            const playerRect = { x: player.x, y: player.y, w: PLAYER_SIZE, h: PLAYER_SIZE };
            const botRect = { x: bot.x, y: bot.y, w: BOT_SIZE, h: BOT_SIZE };

            if (checkCollision(playerRect, botRect)) {
                const centerPlayerX = player.x + player.size / 2;
                const centerPlayerY = player.y + player.size / 2;
                const centerBotX = bot.x + bot.size / 2;
                const centerBotY = bot.y + bot.size / 2;

                const dx = centerBotX - centerPlayerX;
                const dy = centerBotY - centerPlayerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDistance = (player.size + bot.size) / 2;
                const overlap = minDistance - distance;

                if (overlap > 0) {
                    const angle = Math.atan2(dy, dx);
                    // Push the bot away from the player to resolve collision
                    const moveX = overlap * Math.cos(angle) * 0.5; // Push factor 0.5
                    const moveY = overlap * Math.sin(angle) * 0.5;

                    let newBotX = bot.x + moveX;
                    let newBotY = bot.y + moveY;
                    
                    newBotX = Math.max(0, Math.min(newBotX, WIDTH - BOT_SIZE));
                    newBotY = Math.max(0, Math.min(newBotY, HEIGHT - BOT_SIZE));
                    
                    if (!checkObstacleCollision(bot, newBotX, newBotY)) {
                        bot.x = newBotX;
                        bot.y = newBotY;
                    } 
                }
            }
        }


        // === Game Logic Functions ===

        function resetGame() {
            gameState.running = false;
            gameState.gameOver = false;
            gameState.startTime = Date.now();
            gameState.elapsedTime = 0;
            gameState.player.alive = true;
            gameState.bot.alive = true;
            gameState.player.x = WIDTH / 2 - PLAYER_SIZE / 2;
            gameState.player.y = HEIGHT / 2 - PLAYER_SIZE / 2;
            gameState.bot.x = WIDTH / 2 - BOT_SIZE / 2 + 80;
            gameState.bot.y = HEIGHT / 2 - BOT_SIZE / 2 + 80;
            gameState.player.dx = 0;
            gameState.player.dy = 0;
            gameState.bot.dx = 0;
            gameState.bot.dy = 0;
            gameState.obstacles = [];
            gameState.spike.activeSide = null;
            gameState.spike.warningTimer = 0;
            gameState.spike.growth = 0;
            gameState.spike.isWarning = false;
            gameState.spike.segmentBlockLengths.fill(MAX_SPIKE_LENGTH);
            gameState.spike.durationTimer = 0;
            gameState.spike.maxDuration = 0; 
            gameState.joystick.dx = 0;
            gameState.joystick.dy = 0;
            resetJoystickHandle();

            spawnObstacles(MAX_OBSTACLES);

            PLAYER_STATUS.textContent = 'ALIVE';
            PLAYER_STATUS.style.color = PLAYER_COLOR;
            BOT_STATUS.textContent = 'ALIVE';
            BOT_STATUS.style.color = BOT_COLOR;
            TIME_DISPLAY.textContent = '0.00';

            UI_OVERLAY.classList.remove('active');
            
            if (gameState.frameId) {
                cancelAnimationFrame(gameState.frameId);
            }
            gameState.lastFrameTime = performance.now();
            gameState.running = true;
            gameState.frameId = requestAnimationFrame(gameLoop);
        }

        function handleInput(deltaTime) {
            if (!gameState.player.alive) return;

            // Use joystick input (preferred for mobile)
            gameState.player.dx = gameState.joystick.dx * MAX_SPEED;
            gameState.player.dy = gameState.joystick.dy * MAX_SPEED;
            
            // Add keyboard fallback (for hybrid devices)
            if (gameState.joystick.dx === 0 && gameState.joystick.dy === 0) {
                 if (gameState.keys['w']) gameState.player.dy -= MAX_SPEED;
                 if (gameState.keys['s']) gameState.player.dy += MAX_SPEED;
                 if (gameState.keys['a']) gameState.player.dx -= MAX_SPEED;
                 if (gameState.keys['d']) gameState.player.dx += MAX_SPEED;
                 
                 // Normalize PC diagonal movement
                if (gameState.player.dx !== 0 && gameState.player.dy !== 0) {
                    const factor = 1 / Math.sqrt(2);
                    gameState.player.dx *= factor;
                    gameState.player.dy *= factor;
                }
            }


            let newX = gameState.player.x + gameState.player.dx;
            let newY = gameState.player.y + gameState.player.dy;

            newX = Math.max(0, Math.min(newX, WIDTH - PLAYER_SIZE));
            newY = Math.max(0, Math.min(newY, HEIGHT - PLAYER_SIZE));

            if (!checkObstacleCollision(gameState.player, newX, gameState.player.y)) {
                gameState.player.x = newX;
            }
            if (!checkObstacleCollision(gameState.player, gameState.player.x, newY)) {
                gameState.player.y = newY;
            }
        }

        function botAI(deltaTime) {
            const bot = gameState.bot;
            if (!bot.alive) return;

            const speed = BOT_WANDER_SPEED;
            let targetSpeedX = 0;
            let targetSpeedY = 0;

            // 1. Evasion Logic (Highest Priority)
            if (gameState.spike.isWarning || gameState.spike.growth > 0) {
                const side = gameState.spike.activeSide;
                const buffer = 30; 
                const spike = gameState.spike;

                let segmentIndex;
                const isHorizontal = (side === 'top' || side === 'bottom');
                const segmentDimension = isHorizontal ? WIDTH : HEIGHT;
                const segmentBaseSize = segmentDimension / SEGMENTS;

                if (isHorizontal) {
                    segmentIndex = Math.floor((bot.x + bot.size / 2) / segmentBaseSize);
                } else {
                    segmentIndex = Math.floor((bot.y + bot.size / 2) / segmentBaseSize);
                }
                segmentIndex = Math.min(Math.max(0, segmentIndex), SEGMENTS - 1);
                
                const segmentMaxGrowth = spike.segmentBlockLengths[segmentIndex];

                let safeDist;
                switch (side) {
                    case 'top':
                        safeDist = segmentMaxGrowth + buffer;
                        if (bot.y < safeDist) targetSpeedY = speed; 
                        break;
                    case 'bottom':
                        safeDist = HEIGHT - segmentMaxGrowth - buffer;
                        if (bot.y + bot.size > safeDist) targetSpeedY = -speed; 
                        break;
                    case 'left':
                        safeDist = segmentMaxGrowth + buffer;
                        if (bot.x < safeDist) targetSpeedX = speed; 
                        break;
                    case 'right':
                        safeDist = WIDTH - segmentMaxGrowth - buffer;
                        if (bot.x + bot.size > safeDist) targetSpeedX = -speed; 
                        break;
                }
                
                if (targetSpeedX !== 0 || targetSpeedY !== 0) {
                    bot.dx = targetSpeedX;
                    bot.dy = targetSpeedY;
                } else {
                    // If not actively evading, continue moving towards the target
                    const dx = bot.targetX - (bot.x + bot.size / 2);
                    const dy = bot.targetY - (bot.y + bot.size / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        bot.dx = (dx / dist) * speed;
                        bot.dy = (dy / dist) * speed;
                    }
                }

            } else {
                // 2. Wandering Logic
                const dx = bot.targetX - (bot.x + bot.size / 2);
                const dy = bot.targetY - (bot.y + bot.size / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 10 || bot.stuckTimer > 30) { 
                    wander(bot, speed);
                    bot.stuckTimer = 0;
                }

                targetSpeedX = (dx / dist) * speed;
                targetSpeedY = (dy / dist) * speed;
                
                bot.dx = targetSpeedX;
                bot.dy = targetSpeedY;
            }
            
            if (bot.dx !== 0 && bot.dy !== 0) {
                const factor = 1 / Math.sqrt(2);
                bot.dx *= factor;
                bot.dy *= factor;
            }

            let newX = bot.x + bot.dx;
            let newY = bot.y + bot.dy;

            if (Math.abs(bot.x - newX) < 0.1 && Math.abs(bot.y - newY) < 0.1 && (bot.dx !== 0 || bot.dy !== 0)) {
                bot.stuckTimer++;
            } else {
                bot.stuckTimer = 0;
            }

            newX = Math.max(0, Math.min(newX, WIDTH - BOT_SIZE));
            newY = Math.max(0, Math.min(newY, HEIGHT - BOT_SIZE));
            
            // Obstacle collision check and slide logic
            if (!checkObstacleCollision(bot, newX, newY)) {
                bot.x = newX;
                bot.y = newY;
            } else {
                if (!checkObstacleCollision(bot, newX, bot.y)) {
                    bot.x = newX;
                } else if (!checkObstacleCollision(bot, bot.x, newY)) {
                    bot.y = newY;
                } else {
                    // Fully blocked, recalculate target to escape
                    wander(bot, speed);
                }
            }
        }

        function wander(bot, speed) {
            bot.targetX = getRandomCoord(bot.size) + bot.size / 2;
            bot.targetY = getRandomCoord(bot.size) + bot.size / 2;
        }

        function calculateSegmentBlockLengths() {
            const side = gameState.spike.activeSide;
            const isHorizontal = (side === 'top' || side === 'bottom');
            const segmentDimension = isHorizontal ? WIDTH : HEIGHT;
            const segmentBaseSize = segmentDimension / SEGMENTS;
            
            const blockLengths = new Array(SEGMENTS).fill(MAX_SPIKE_LENGTH);

            for (let i = 0; i < SEGMENTS; i++) {
                const startCoord = i * segmentBaseSize;
                const endCoord = (i + 1) * segmentBaseSize;
                let minDistance = MAX_SPIKE_LENGTH;

                for (const obs of gameState.obstacles) {
                    let dist = MAX_SPIKE_LENGTH;
                    let isAligned = false;

                    if (isHorizontal) {
                        if (obs.x < endCoord && obs.x + OBSTACLE_SIZE > startCoord) {
                            isAligned = true;
                            // Distance is from the canvas edge to the near edge of the obstacle
                            dist = (side === 'top') ? obs.y : HEIGHT - (obs.y + OBSTACLE_SIZE);
                        }
                    } else {
                        if (obs.y < endCoord && obs.y + OBSTACLE_SIZE > startCoord) {
                            isAligned = true;
                            dist = (side === 'left') ? obs.x : WIDTH - (obs.x + OBSTACLE_SIZE);
                        }
                    }

                    if (isAligned && dist < minDistance) {
                        minDistance = dist;
                    }
                }
                // Store the maximum clear distance (to the obstacle edge)
                blockLengths[i] = minDistance;
            }
            return blockLengths;
        }


        function updateSpikes(deltaTimeMs) {
            const spike = gameState.spike;
            const timeSeconds = gameState.elapsedTime;

            // Speed increases over time
            spike.growthSpeed = INITIAL_SPIKE_GROWTH_SPEED_PX_PER_MS + (timeSeconds / 60) * 0.5;
            spike.growthSpeed = Math.min(1.0, spike.growthSpeed); 

            // Handle obstacle spawning
            if (timeSeconds > 0 && Math.floor(timeSeconds) % 15 === 0 && Math.floor(timeSeconds) !== Math.floor(gameState.elapsedTime - deltaTimeMs/1000) && gameState.obstacles.length < MAX_OBSTACLES) {
                spawnObstacles(1);
            }

            if (spike.activeSide === null) {
                spike.activeSide = ['top', 'right', 'bottom', 'left'][Math.floor(Math.random() * 4)];
                spike.isWarning = true;
                spike.warningTimer = spike.maxWarning;
                spike.growth = 0;
                spike.durationTimer = 0;
                spike.maxDuration = (Math.random() * 3000) + 7000; 
                spike.segmentBlockLengths = calculateSegmentBlockLengths(); 
            } else if (spike.isWarning) {
                spike.warningTimer -= deltaTimeMs;
                if (spike.warningTimer <= 0) {
                    spike.isWarning = false;
                }
            } else {
                spike.durationTimer += deltaTimeMs;

                // Growth is independent of segment blocks, up to MAX_SPIKE_LENGTH
                if (spike.growth < MAX_SPIKE_LENGTH) { 
                    spike.growth += spike.growthSpeed * deltaTimeMs;
                    spike.growth = Math.min(spike.growth, MAX_SPIKE_LENGTH);
                }

                if (spike.durationTimer >= spike.maxDuration) {
                    spike.activeSide = null; 
                    spike.growth = 0;
                }
            }
        }

        function spawnObstacles(count) {
            let attempts = 0;
            const centerArea = { x: WIDTH/2 - 100, y: HEIGHT/2 - 100, w: 200, h: 200 };
            
            while (count > 0 && gameState.obstacles.length < MAX_OBSTACLES && attempts < 100) {
                const newObs = { x: getRandomCoord(OBSTACLE_SIZE), y: getRandomCoord(OBSTACLE_SIZE), w: OBSTACLE_SIZE, h: OBSTACLE_SIZE };
                const newObsRect = { x: newObs.x, y: newObs.y, w: OBSTACLE_SIZE, h: OBSTACLE_SIZE };
                let collisionFound = false;

                // Check collision with existing obstacles
                for (const obs of gameState.obstacles) {
                    const obsRect = { x: obs.x, y: obs.y, w: OBSTACLE_SIZE, h: OBSTACLE_SIZE };
                    // Give a small buffer between obstacles
                    if (checkCollision(newObsRect, {...obsRect, x: obsRect.x - 5, y: obsRect.y - 5, w: obsRect.w + 10, h: obsRect.h + 10 })) {
                        collisionFound = true;
                        break;
                    }
                }

                // Check collision with center area
                 if (checkCollision(newObsRect, centerArea)) {
                    collisionFound = true;
                }

                if (!collisionFound) {
                    gameState.obstacles.push(newObs);
                    count--;
                }
                attempts++;
            }
        }

        function checkSpikeCollision() {
            const spike = gameState.spike;
            if (spike.growth <= 0 || gameState.gameOver) return;

            const isHorizontal = (spike.activeSide === 'top' || spike.activeSide === 'bottom');
            const segmentDimension = isHorizontal ? WIDTH : HEIGHT;
            const segmentBaseSize = segmentDimension / SEGMENTS;
            
            const checkCollisionForCharacter = (character) => {
                if (!character.alive) return false;

                // Find the segment the character is in
                let segmentIndex;
                if (isHorizontal) {
                    segmentIndex = Math.floor((character.x + character.size / 2) / segmentBaseSize);
                } else {
                    segmentIndex = Math.floor((character.y + character.size / 2) / segmentBaseSize);
                }
                segmentIndex = Math.min(Math.max(0, segmentIndex), SEGMENTS - 1);
                
                const segmentMaxGrowth = gameState.spike.segmentBlockLengths[segmentIndex];
                
                // Segment length is capped by its block length (to the obstacle edge) + TIP_SIZE
                const segmentCurrentLength = Math.min(spike.growth, segmentMaxGrowth + TIP_SIZE); 
                
                if (segmentCurrentLength <= 0) return false;

                let spikeRect = { x: 0, y: 0, w: WIDTH, h: HEIGHT };
                
                // Define the hitbox for the active spike segment
                switch (spike.activeSide) {
                    case 'top':
                        const xStartTop = segmentIndex * segmentBaseSize;
                        const xEndTop = (segmentIndex + 1) * segmentBaseSize;
                        spikeRect = { x: xStartTop, y: 0, w: xEndTop - xStartTop, h: segmentCurrentLength };
                        break;
                    case 'bottom':
                         const xStartBottom = segmentIndex * segmentBaseSize;
                         const xEndBottom = (segmentIndex + 1) * segmentBaseSize;
                        spikeRect = { x: xStartBottom, y: HEIGHT - segmentCurrentLength, w: xEndBottom - xStartBottom, h: segmentCurrentLength };
                        break;
                    case 'left':
                        const yStartLeft = segmentIndex * segmentBaseSize;
                        const yEndLeft = (segmentIndex + 1) * segmentBaseSize;
                        spikeRect = { x: 0, y: yStartLeft, w: segmentCurrentLength, h: yEndLeft - yStartLeft };
                        break;
                    case 'right':
                        const yStartRight = segmentIndex * segmentBaseSize;
                        const yEndRight = (segmentIndex + 1) * segmentBaseSize;
                        spikeRect = { x: WIDTH - segmentCurrentLength, y: yStartRight, w: segmentCurrentLength, h: yEndRight - yStartRight };
                        break;
                }

                const charRect = { x: character.x, y: character.y, w: character.size, h: character.size };
                
                if (checkCollision(charRect, spikeRect)) {
                    character.alive = false;
                    return true;
                }
                return false;
            };

            if (checkCollisionForCharacter(gameState.player)) {
                PLAYER_STATUS.textContent = 'DESTROYED';
                PLAYER_STATUS.style.color = WARNING_COLOR_RED;
                endGame(); 
                return;
            }

            if (checkCollisionForCharacter(gameState.bot)) {
                BOT_STATUS.textContent = 'DESTROYED';
                BOT_STATUS.style.color = WARNING_COLOR_RED;
                if (!gameState.player.alive) {
                    endGame();
                }
            }
            
            if (gameState.player.alive && !gameState.bot.alive) {
                 endGame(); // Player survived the bot
            }
        }

        function endGame() {
            if (gameState.gameOver) return; 

            gameState.running = false;
            gameState.gameOver = true;
            resetJoystickHandle();

            const timeSurvived = gameState.elapsedTime;
            let message = '';

            if (gameState.player.alive && !gameState.bot.alive) {
                message = 'PLAYER VICTORIOUS!'; 
                PLAYER_STATUS.style.color = '#ffff00'; // Gold color
            } else if (!gameState.player.alive && gameState.bot.alive) {
                message = 'PLAYER DEFEATED!'; 
                BOT_STATUS.style.color = '#ffff00'; // Gold color
            } else if (!gameState.player.alive && !gameState.bot.alive) {
                message = 'MUTUAL ANNIHILATION';
            } else {
                 message = 'SIMULATION COMPLETE';
            }

            if (timeSurvived > gameState.highScore) {
                gameState.highScore = timeSurvived;
                localStorage.setItem('spikeArenaHighScore', timeSurvived.toFixed(2));
                HIGH_SCORE_DISPLAY.textContent = timeSurvived.toFixed(2);
            }

            GAME_MESSAGE.textContent = message;
            RESTART_BUTTON.textContent = 'RESTART SIMULATION';
            UI_OVERLAY.classList.add('active');
        }

        function update(currentTime) {
            if (!gameState.running) return;

            const deltaTimeMs = currentTime - gameState.lastFrameTime;
            gameState.lastFrameTime = currentTime;
            const deltaTime = deltaTimeMs / 1000;

            if (gameState.player.alive || gameState.bot.alive) {
                gameState.elapsedTime += deltaTime;
            } else {
                 return;
            }

            TIME_DISPLAY.textContent = gameState.elapsedTime.toFixed(2);

            if (gameState.player.alive) handleInput(deltaTime);
            if (gameState.bot.alive) botAI(deltaTime);

            handlePlayerBotCollision();

            updateSpikes(deltaTimeMs);
            
            checkSpikeCollision();
        }

        // === Rendering Functions ===

        function drawSpike(side, currentLength, color) {
            CTX.fillStyle = color;
            
            // Add a subtle glow for the spike
            CTX.shadowBlur = 10;
            CTX.shadowColor = color;

            const isHorizontal = (side === 'top' || side === 'bottom');
            const segmentDimension = isHorizontal ? WIDTH : HEIGHT;
            const segmentBaseSize = segmentDimension / SEGMENTS;
            
            for (let i = 0; i < SEGMENTS; i++) {
                const fullStart = i * segmentBaseSize;
                const fullEnd = (i + 1) * segmentBaseSize;
                
                const startCoord = fullStart + SEGMENT_GAP / 2;
                const endCoord = fullEnd - SEGMENT_GAP / 2;
                
                if (startCoord >= endCoord) continue;

                const midCoord = (startCoord + endCoord) / 2;

                const maxSegmentLength = gameState.spike.segmentBlockLengths[i];
                
                // Draw length is limited by the overall growth AND the segment's block length
                const drawLength = Math.min(currentLength, maxSegmentLength + TIP_SIZE); 
                
                if (drawLength <= 0) continue; 
                
                const drawBodyLength = Math.max(0, drawLength - TIP_SIZE); 

                CTX.beginPath();
                if (side === 'top') {
                    CTX.moveTo(startCoord, 0);                 
                    CTX.lineTo(endCoord, 0);                   
                    CTX.lineTo(endCoord, drawBodyLength);      
                    CTX.lineTo(midCoord, drawLength);          
                    CTX.lineTo(startCoord, drawBodyLength);    
                } else if (side === 'bottom') {
                    CTX.moveTo(startCoord, HEIGHT);            
                    CTX.lineTo(endCoord, HEIGHT);              
                    CTX.lineTo(endCoord, HEIGHT - drawBodyLength);
                    CTX.lineTo(midCoord, HEIGHT - drawLength);
                    CTX.lineTo(startCoord, HEIGHT - drawBodyLength);
                } else if (side === 'left') {
                    CTX.moveTo(0, startCoord);                 
                    CTX.lineTo(0, endCoord);                   
                    CTX.lineTo(drawBodyLength, endCoord);
                    CTX.lineTo(drawLength, midCoord);
                    CTX.lineTo(drawBodyLength, startCoord);
                } else if (side === 'right') {
                    CTX.moveTo(WIDTH, startCoord);             
                    CTX.lineTo(WIDTH, endCoord);               
                    CTX.lineTo(WIDTH - drawBodyLength, endCoord);
                    CTX.lineTo(WIDTH - drawLength, midCoord);
                    CTX.lineTo(WIDTH - drawBodyLength, startCoord);
                }
                CTX.closePath();
                CTX.fill();
            }
            CTX.shadowBlur = 0; // Reset shadow
        }

        function draw() {
            CTX.clearRect(0, 0, WIDTH, HEIGHT);

            // Draw grid pattern in the background
            CTX.strokeStyle = 'rgba(46, 53, 71, 0.5)';
            CTX.lineWidth = 1;
            for (let i = 0; i < WIDTH; i += 50) {
                CTX.beginPath();
                CTX.moveTo(i, 0);
                CTX.lineTo(i, HEIGHT);
                CTX.stroke();
                CTX.beginPath();
                CTX.moveTo(0, i);
                CTX.lineTo(WIDTH, i);
                CTX.stroke();
            }

            // Draw Obstacles (Glowing squares)
            CTX.fillStyle = OBSTACLE_COLOR;
            CTX.shadowBlur = 10;
            CTX.shadowColor = 'var(--color-steel)';
            for (const obs of gameState.obstacles) {
                CTX.fillRect(obs.x, obs.y, OBSTACLE_SIZE, OBSTACLE_SIZE);
            }
            CTX.shadowBlur = 0;

            // Draw Spike
            const spike = gameState.spike;
            if (spike.activeSide) {
                let color = spike.isWarning ? WARNING_COLOR_RED : SPIKE_COLOR; 

                // Flashing warning effect
                if (spike.isWarning && Math.floor(gameState.elapsedTime * 6) % 2) {
                    drawSpike(spike.activeSide, 10, color); 
                } else if (!spike.isWarning) {
                    drawSpike(spike.activeSide, spike.growth, color);
                }
            }

            // Draw Player
            if (gameState.player.alive) {
                CTX.fillStyle = gameState.player.color;
                CTX.shadowBlur = 15;
                CTX.shadowColor = gameState.player.color;
                CTX.fillRect(gameState.player.x, gameState.player.y, PLAYER_SIZE, PLAYER_SIZE);
                CTX.shadowBlur = 0; 
            } else if (!gameState.running) {
                // Ghosted defeated state
                CTX.fillStyle = 'rgba(0, 229, 255, 0.2)';
                CTX.fillRect(gameState.player.x, gameState.player.y, PLAYER_SIZE, PLAYER_SIZE);
            }

            // Draw Bot
            if (gameState.bot.alive) {
                CTX.fillStyle = gameState.bot.color;
                CTX.shadowBlur = 15;
                CTX.shadowColor = gameState.bot.color;
                CTX.fillRect(gameState.bot.x, gameState.bot.y, BOT_SIZE, BOT_SIZE);
                CTX.shadowBlur = 0; 
            } else if (!gameState.running) {
                // Ghosted defeated state
                CTX.fillStyle = 'rgba(255, 0, 255, 0.2)';
                CTX.fillRect(gameState.bot.x, gameState.bot.y, BOT_SIZE, BOT_SIZE);
            }
        }

        // === Game Loop ===
        function gameLoop(currentTime) {
            update(currentTime);
            draw();

            if (gameState.running) {
                gameState.frameId = requestAnimationFrame(gameLoop);
            }
        }

        // === Joystick Logic ===
        let activeTouchId = null;

        function startJoystick(e) {
            // Prevent default scrolling/zooming immediately
            if (e.cancelable) e.preventDefault(); 
            if (activeTouchId !== null || !gameState.running) return;

            const rect = JOYSTICK_CONTAINER.getBoundingClientRect();
            const touch = e.changedTouches[0];
            
            // Check if the touch started within the joystick area (with a buffer)
            const buffer = 10;
            if (touch.clientX >= rect.left - buffer && touch.clientX <= rect.right + buffer &&
                touch.clientY >= rect.top - buffer && touch.clientY <= rect.bottom + buffer) {
                activeTouchId = touch.identifier;
                handleMoveJoystick(e); // Process the initial touch location
                
                // Add visual feedback on touch start
                JOYSTICK_HANDLE.style.boxShadow = `0 0 30px ${BOT_COLOR}`;
                JOYSTICK_HANDLE.style.background = BOT_COLOR;
            }
        }

        function handleMoveJoystick(e) {
            if (e.cancelable) e.preventDefault(); 
            if (activeTouchId === null) return;
            
            let touch = null;
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === activeTouchId) {
                    touch = e.changedTouches[i];
                    break;
                }
            }
            if (!touch) return;
            
            const rect = JOYSTICK_CONTAINER.getBoundingClientRect();
            // Calculate coordinates relative to the center of the container
            const containerX = rect.left;
            const containerY = rect.top;
            
            let deltaX = touch.clientX - (containerX + JOYSTICK_CENTER);
            let deltaY = touch.clientY - (containerY + JOYSTICK_CENTER);

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > MAX_JOYSTICK_DISTANCE) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * MAX_JOYSTICK_DISTANCE;
                deltaY = Math.sin(angle) * MAX_JOYSTICK_DISTANCE;
            }

            // Update handle position
            JOYSTICK_HANDLE.style.left = `${JOYSTICK_CENTER + deltaX}px`;
            JOYSTICK_HANDLE.style.top = `${JOYSTICK_CENTER + deltaY}px`;

            // Update game state direction vector (normalized)
            gameState.joystick.dx = deltaX / MAX_JOYSTICK_DISTANCE;
            gameState.joystick.dy = deltaY / MAX_JOYSTICK_DISTANCE;
        }

        function endJoystick(e) {
            if (e.cancelable) e.preventDefault(); 

            if (activeTouchId === null) return;
            
            let touchFound = false;
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === activeTouchId) {
                    touchFound = true;
                    break;
                }
            }
            
            if (touchFound) {
                activeTouchId = null;
                resetJoystickHandle();
                gameState.joystick.dx = 0;
                gameState.joystick.dy = 0;
                // Reset visual feedback
                JOYSTICK_HANDLE.style.boxShadow = `0 0 20px ${BOT_COLOR}`;
                JOYSTICK_HANDLE.style.background = BOT_COLOR;
            }
        }

        function resetJoystickHandle() {
            JOYSTICK_HANDLE.style.left = `${JOYSTICK_CENTER}px`;
            JOYSTICK_HANDLE.style.top = `${JOYSTICK_CENTER}px`;
        }


        // === Event Listeners ===
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });

        RESTART_BUTTON.addEventListener('click', resetGame);

        // Joystick Event listeners (Passive set to false to allow preventDefault)
        JOYSTICK_CONTAINER.addEventListener('touchstart', startJoystick, { passive: false });
        document.addEventListener('touchmove', handleMoveJoystick, { passive: false });
        document.addEventListener('touchend', endJoystick);
        document.addEventListener('touchcancel', endJoystick);


        // Initial setup to display the start screen
        UI_OVERLAY.classList.add('active');
        draw(); 
    </script>
</body>
</html>
