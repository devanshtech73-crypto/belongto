<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Highway Drifter: Auto-Drive</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #4caf50; /* Green Grass Background */
            font-family: 'Verdana', sans-serif;
            touch-action: none;
            user-select: none; 
            -webkit-user-select: none;
        }
        canvas { display: block; }

        /* Dashboard UI */
        #dashboard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 12px;
            border: 2px solid #333;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            color: #333;
            font-weight: bold;
            z-index: 10;
        }
        .stat-row { display: flex; align-items: center; gap: 15px; margin-bottom: 5px; }
        .gear-box {
            background: #333;
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 18px;
        }
        .speed-text { font-size: 20px; }

        /* Crash Message */
        #message {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            color: #d32f2f;
            font-size: 32px;
            font-weight: 900;
            text-shadow: 2px 2px 0px white;
            pointer-events: none;
            display: none;
            z-index: 20;
        }

        /* Mobile Controls Overlay */
        .controls-area {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 160px;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
            pointer-events: none;
        }
        
        /* Pedals only */
        .pedals {
            display: flex;
            gap: 20px;
            pointer-events: auto;
            align-items: flex-end;
        }

        .btn {
            width: 75px;
            height: 75px;
            background: rgba(0, 0, 0, 0.1);
            border: 2px solid rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-size: 30px;
            font-weight: bold;
        }
        .btn:active { background: rgba(0, 0, 0, 0.3); transform: scale(0.95); }
        
        .btn-rect { border-radius: 15px; width: 65px; height: 100px; }
        .red { background: rgba(255, 50, 50, 0.2); border-color: #d32f2f; }
        .green { background: rgba(50, 255, 50, 0.2); border-color: #388e3c; }

        /* Steering Wheel Visual & Input Area */
        #steering-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            opacity: 0.8;
            pointer-events: auto; /* IMPORTANT: Allows touch input */
        }
        #wheel-img {
            width: 100%;
            height: 100%;
            background: transparent;
            border: 8px solid #333;
            border-radius: 50%;
            box-sizing: border-box;
            position: relative;
            background: rgba(255,255,255,0.2);
        }
        /* Spokes of the wheel */
        #wheel-img::before {
            content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 10px; background: #333; transform: translateY(-50%);
        }
        #wheel-img::after {
            content: ''; position: absolute; bottom: 0; left: 50%; width: 10px; height: 50%; background: #333; transform: translateX(-50%);
        }

    </style>
</head>
<body>

<div id="dashboard">
    <div class="stat-row">
        <span>GEAR</span>
        <div class="gear-box" id="gearDisplay">P</div>
    </div>
    <div class="stat-row">
        <span class="speed-text"><span id="speedVal">0</span> km/h</span>
    </div>
</div>

<div id="message">CRASHED!<br><span style="font-size:16px; color:#333">Tap to Restart</span></div>

<div id="steering-container">
    <div id="wheel-img"></div>
</div>

<div class="controls-area">
    <div class="pedals">
        <div class="btn btn-rect red" id="btnBrake">B</div>
        <div class="btn btn-rect green" id="btnGas">A</div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiSpeed = document.getElementById('speedVal');
const uiGear = document.getElementById('gearDisplay');
const msgBox = document.getElementById('message');
const wheelContainer = document.getElementById('steering-container');
const wheelElement = document.getElementById('wheel-img');

// --- CONFIG ---
const ROAD_WIDTH = 500;
const ROAD_CENTER_X = 0; // Relative to world space

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- INPUTS ---
const keys = { Gas: false, Brake: false, SteerAmount: 0 }; // SteerAmount is -1 to 1
let visualSteerAngle = 0;

// Keyboard input
window.addEventListener('keydown', (e) => {
    if(e.key === 'ArrowUp' || e.key === 'w') keys.Gas = true;
    if(e.key === 'ArrowDown' || e.key === 's') keys.Brake = true;
    if(e.key === 'ArrowLeft' || e.key === 'a') keys.SteerAmount = -1;
    if(e.key === 'ArrowRight' || e.key === 'd') keys.SteerAmount = 1;
});
window.addEventListener('keyup', (e) => {
    if(e.key === 'ArrowUp' || e.key === 'w') keys.Gas = false;
    if(e.key === 'ArrowDown' || e.key === 's') keys.Brake = false;
    if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'ArrowRight' || e.key === 'd') keys.SteerAmount = 0;
});

// Touch mapping helper for pedals
document.getElementById('btnGas').addEventListener('touchstart', (e) => { e.preventDefault(); keys.Gas = true; });
document.getElementById('btnGas').addEventListener('touchend', (e) => { e.preventDefault(); keys.Gas = false; });
document.getElementById('btnBrake').addEventListener('touchstart', (e) => { e.preventDefault(); keys.Brake = true; });
document.getElementById('btnBrake').addEventListener('touchend', (e) => { e.preventDefault(); keys.Brake = false; });

// Steering Wheel Input Logic
let isTouchingWheel = false;

function handleWheelStart(e) {
    if (!gameState.active) return;
    isTouchingWheel = true;
    handleWheelMove(e.touches ? e.touches[0] : e);
}

function handleWheelMove(e) {
    if (!isTouchingWheel) return;
    const rect = wheelContainer.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);

    // Calculate position relative to center of wheel (-1 to 1)
    let relativeX = (clientX - centerX) / (rect.width / 2);

    // Clamp and apply a cubic easing curve for smoother steering response near center
    relativeX = Math.max(-1, Math.min(1, relativeX));
    keys.SteerAmount = relativeX * Math.abs(relativeX);
}

function handleWheelEnd() {
    isTouchingWheel = false;
    keys.SteerAmount = 0;
}

// Bind touch events to the steering container
wheelContainer.addEventListener('mousedown', handleWheelStart);
wheelContainer.addEventListener('mousemove', handleWheelMove);
document.addEventListener('mouseup', handleWheelEnd);
wheelContainer.addEventListener('touchstart', handleWheelStart);
wheelContainer.addEventListener('touchmove', handleWheelMove);
document.addEventListener('touchend', handleWheelEnd);

// Restart handler
window.addEventListener('touchstart', () => { if(!gameState.active) resetGame(); });
window.addEventListener('keydown', (e) => { if(!gameState.active && e.key === " ") resetGame(); });

// --- GAME OBJECTS ---
const gameState = { active: true };

const car = {
    x: 0, y: 0,
    w: 26, h: 48,
    angle: -Math.PI / 2,
    vx: 0, vy: 0,
    speed: 0,
    gear: 'P',
    // Physics
    maxCruiseSpeed: 16,
    maxBoostSpeed: 30,
    accel: 0.3,
    friction: 0.97,
    turnSpeed: 0.05,
    grip: 0.88 // Lower for more drift
};

let traffic = [];
let particles = [];
let skids = [];

function resetGame() {
    car.x = 0; 
    car.y = 0;
    car.vx = 0; car.vy = 0; 
    car.angle = -Math.PI / 2;
    traffic = [];
    skids = [];
    gameState.active = true;
    msgBox.style.display = 'none';
}

// --- PHYSICS ---
function updatePhysics() {
    if (!gameState.active) return;

    // 1. Automatic Drive & Throttle
    let thrust = 0;
    let targetSpeed = car.maxCruiseSpeed;

    if (keys.Gas) { // Gas pedal is now a boost
        targetSpeed = car.maxBoostSpeed;
    } else if (keys.Brake) { // Brake
        targetSpeed = 0;
        thrust = -car.accel; // Immediate braking force
    }

    // Automatic acceleration to cruise speed
    const currentSpeedMagnitude = car.speed;
    if (currentSpeedMagnitude < targetSpeed) {
        thrust = car.accel * (1 - currentSpeedMagnitude / targetSpeed);
    } else if (currentSpeedMagnitude > targetSpeed) {
        thrust = -car.accel * 0.5; // Decelerate if over target speed
    }

    // 2. Steering & Wheel Visual
    let steerFactor = keys.SteerAmount;
    
    // Smooth visual wheel rotation
    visualSteerAngle += (steerFactor * 120 - visualSteerAngle) * 0.15;
    wheelElement.style.transform = `rotate(${visualSteerAngle}deg)`;

    // Apply steering to car (Steering is reduced at low speed and increased by drift)
    if (currentSpeedMagnitude > 0.5) {
        const turnRate = car.turnSpeed * (1 + currentSpeedMagnitude / car.maxBoostSpeed);
        car.angle += turnRate * steerFactor;
    }
    
    // 3. Move Car
    car.vx += Math.cos(car.angle) * thrust;
    car.vy += Math.sin(car.angle) * thrust;

    // Friction
    car.vx *= car.friction;
    car.vy *= car.friction;

    car.speed = Math.sqrt(car.vx**2 + car.vy**2);

    // Drift Logic (Enhanced)
    if (car.speed > 0.1) {
        const hx = Math.cos(car.angle);
        const hy = Math.sin(car.angle);
        
        // Lateral velocity component reduction
        const moveAngle = Math.atan2(car.vy, car.vx);
        const perpAngle = car.angle + Math.PI / 2;
        const lateralX = Math.cos(perpAngle);
        const lateralY = Math.sin(perpAngle);

        // Project current velocity onto car's lateral axis
        const lateralVelocity = car.vx * lateralX + car.vy * lateralY;

        // Reduce lateral velocity (this is the true grip/drift factor)
        car.vx -= lateralX * lateralVelocity * (1 - car.grip);
        car.vy -= lateralY * lateralVelocity * (1 - car.grip);
    }

    car.x += car.vx;
    car.y += car.vy;

    // 4. Barrier Collision
    const roadEdge = ROAD_WIDTH / 2 - 20;
    if (car.x < -roadEdge || car.x > roadEdge) {
        if (car.speed * 8 > 70) { // Crash above 70kph
            gameState.active = false;
            msgBox.style.display = 'block';
            createExplosion(car.x, car.y, '#333');
        } else {
            // Low speed bounce
            car.x = (car.x < 0) ? -roadEdge : roadEdge;
            car.vx *= -0.5;
            car.vy *= 0.9;
        }
    }

    // 5. Gearbox Logic
    const kph = Math.floor(car.speed * 8);
    if(kph < 1) car.gear = (keys.Brake) ? 'R' : 'P';
    else if(kph < 40) car.gear = '1';
    else if(kph < 80) car.gear = '2';
    else if(kph < 120) car.gear = '3';
    else car.gear = '4';

    uiSpeed.innerText = kph;
    uiGear.innerText = car.gear;

    // 6. Traffic Spawning & Collision
    manageTraffic();
    
    // 7. Skidmarks
    const moveAngle = Math.atan2(car.vy, car.vx);
    const drift = Math.abs(Math.sin(moveAngle - car.angle)) * car.speed;
    if (drift > 3) { // Higher threshold for drift
        const c = Math.cos(car.angle), s = Math.sin(car.angle);
        skids.push({x: car.x - c*20 - s*10, y: car.y - s*20 + c*10, a: 0.4});
        skids.push({x: car.x - c*20 + s*10, y: car.y - s*20 - c*10, a: 0.4});
    }
}

function manageTraffic() {
    // Spawn ahead
    if (traffic.length < 4 && car.speed > 2 && Math.random() < 0.02) {
        const lane = (Math.random() > 0.5) ? 1 : -1;
        const xPos = lane * (ROAD_WIDTH/4); 
        const yPos = car.y + (Math.sin(car.angle) * 1000) + (Math.random()*200);
        
        traffic.push({
            x: xPos, y: yPos,
            w: 26, h: 48,
            angle: car.angle + (Math.random()-0.5)*0.1, 
            speed: 8 + Math.random() * 6, // Slower than player
            color: ['#1e88e5', '#8e24aa', '#fdd835', '#43a047'][Math.floor(Math.random()*4)]
        });
    }

    // Move & Collide
    for (let i = 0; i < traffic.length; i++) {
        let t = traffic[i];
        t.x += Math.cos(t.angle) * t.speed;
        t.y += Math.sin(t.angle) * t.speed;

        // Collision
        if (Math.hypot(car.x - t.x, car.y - t.y) < 30) {
            gameState.active = false;
            msgBox.style.display = 'block';
            createExplosion((car.x+t.x)/2, (car.y+t.y)/2, t.color);
        }

        // Cleanup
        if (Math.hypot(car.x - t.x, car.y - t.y) > 1500) {
            traffic.splice(i, 1);
            i--;
        }
    }
}

function createExplosion(x, y, color) {
    for(let k=0; k<25; k++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12,
            life: 60, color: color
        });
    }
}

// --- DRAWING ---
function draw() {
    // Background (Grass)
    ctx.fillStyle = '#4caf50';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    // Camera follow (Main translation)
    ctx.translate(canvas.width/2 - car.x, canvas.height/2 - car.y);

    // 1. Road
    const drawDist = 1000;
    const roadTop = car.y - drawDist;
    const roadBot = car.y + drawDist;
    
    // Main Asphalt
    ctx.fillStyle = '#666'; 
    ctx.fillRect(-ROAD_WIDTH/2, roadTop, ROAD_WIDTH, (roadBot-roadTop));

    // Road Markings (Dashed Line)
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 4;
    ctx.setLineDash([30, 30]);
    ctx.beginPath();
    ctx.moveTo(0, roadTop);
    ctx.lineTo(0, roadBot);
    ctx.stroke();
    ctx.setLineDash([]);

    // Barriers (Red/White rails)
    const barrierSize = 40;
    for(let y = roadTop - (roadTop%barrierSize); y < roadBot; y+=barrierSize) {
        // Left Barrier
        ctx.fillStyle = (Math.floor(y/barrierSize) % 2 === 0) ? '#d32f2f' : '#fff';
        ctx.fillRect(-ROAD_WIDTH/2 - 10, y, 10, barrierSize);
        // Right Barrier
        ctx.fillRect(ROAD_WIDTH/2, y, 10, barrierSize);
    }

    // 2. Skids
    for (let s of skids) {
        ctx.fillStyle = '#333';
        ctx.globalAlpha = s.a;
        ctx.fillRect(s.x, s.y, 4, 4);
        s.a -= 0.005;
        ctx.globalAlpha = 1;
    }

    // 3. Traffic
    for (let t of traffic) {
        drawVehicle(t.x, t.y, t.angle, t.color, false);
    }

    // 4. Player Car
    drawVehicle(car.x, car.y, car.angle, '#f57f17', true);

    // 5. Particles
    for (let i = 0; i < particles.length; i++) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.life--;
        ctx.fillStyle = p.color;
        ctx.beginPath(); 
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2); 
        ctx.fill();
        if(p.life<=0) { particles.splice(i,1); i--; }
    }

    ctx.restore();
    updatePhysics();
    requestAnimationFrame(draw);
}

function drawVehicle(x, y, angle, color, isPlayer) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(-22, -10, 48, 26);

    // Body
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(-24, -13, 48, 26, 4);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Roof / Windshield
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.roundRect(-10, -11, 24, 22, 3);
    ctx.fill();

    // Lights
    if(isPlayer && keys.Brake) {
        ctx.fillStyle = '#ff0000'; // Braking
        ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10;
    } else {
        ctx.fillStyle = '#800000'; // Normal tail lights
        ctx.shadowBlur = 0;
    }
    // Tail lights
    ctx.fillRect(-24, -12, 2, 6);
    ctx.fillRect(-24, 6, 2, 6);
    ctx.shadowBlur = 0;

    // Headlights
    ctx.fillStyle = '#fff9c4';
    ctx.fillRect(22, -12, 2, 6);
    ctx.fillRect(22, 6, 2, 6);

    ctx.restore();
}

resetGame();
draw();
</script>
</body>
</html>
