<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Highway Drifter: Light Mode</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #4caf50; /* Green Grass Background */
            font-family: 'Verdana', sans-serif;
            touch-action: none;
            user-select: none; 
            -webkit-user-select: none;
        }
        canvas { display: block; }

        /* Dashboard UI */
        #dashboard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 12px;
            border: 2px solid #333;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            color: #333;
            font-weight: bold;
            z-index: 10;
        }
        .stat-row { display: flex; align-items: center; gap: 15px; margin-bottom: 5px; }
        .gear-box {
            background: #333;
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 18px;
        }
        .speed-text { font-size: 20px; }

        /* Crash Message */
        #message {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            color: #d32f2f;
            font-size: 32px;
            font-weight: 900;
            text-shadow: 2px 2px 0px white;
            pointer-events: none;
            display: none;
            z-index: 20;
        }

        /* Mobile Controls Overlay */
        .controls-area {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 160px;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
            pointer-events: none;
        }
        
        .dpad, .pedals {
            display: flex;
            gap: 20px;
            pointer-events: auto;
            align-items: flex-end;
        }

        .btn {
            width: 75px;
            height: 75px;
            background: rgba(0, 0, 0, 0.1);
            border: 2px solid rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-size: 30px;
            font-weight: bold;
        }
        .btn:active { background: rgba(0, 0, 0, 0.3); transform: scale(0.95); }
        
        .btn-rect { border-radius: 15px; width: 65px; height: 100px; }
        .red { background: rgba(255, 50, 50, 0.2); border-color: #d32f2f; }
        .green { background: rgba(50, 255, 50, 0.2); border-color: #388e3c; }

        /* Steering Wheel Visual */
        #steering-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            pointer-events: none;
            opacity: 0.8;
        }
        #wheel-img {
            width: 100%;
            height: 100%;
            background: transparent;
            border: 8px solid #333;
            border-radius: 50%;
            box-sizing: border-box;
            position: relative;
            background: rgba(255,255,255,0.2);
        }
        /* Spokes of the wheel */
        #wheel-img::before {
            content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 10px; background: #333; transform: translateY(-50%);
        }
        #wheel-img::after {
            content: ''; position: absolute; bottom: 0; left: 50%; width: 10px; height: 50%; background: #333; transform: translateX(-50%);
        }

    </style>
</head>
<body>

<div id="dashboard">
    <div class="stat-row">
        <span>GEAR</span>
        <div class="gear-box" id="gearDisplay">P</div>
    </div>
    <div class="stat-row">
        <span class="speed-text"><span id="speedVal">0</span> km/h</span>
    </div>
</div>

<div id="message">CRASHED!<br><span style="font-size:16px; color:#333">Tap to Restart</span></div>

<div id="steering-container">
    <div id="wheel-img"></div>
</div>

<div class="controls-area">
    <div class="dpad">
        <div class="btn" id="btnLeft">◄</div>
        <div class="btn" id="btnRight">►</div>
    </div>
    <div class="pedals">
        <div class="btn btn-rect red" id="btnBrake"></div>
        <div class="btn btn-rect green" id="btnGas"></div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiSpeed = document.getElementById('speedVal');
const uiGear = document.getElementById('gearDisplay');
const msgBox = document.getElementById('message');
const wheelElement = document.getElementById('wheel-img');

// --- CONFIG ---
const ROAD_WIDTH = 500; // Width of the asphalt
const BARRIER_width = 20;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- INPUTS ---
const keys = { Up: false, Down: false, Left: false, Right: false };
let visualSteerAngle = 0;

function setKey(key, state) {
    if(key === 'ArrowUp' || key === 'w') keys.Up = state;
    if(key === 'ArrowDown' || key === 's') keys.Down = state;
    if(key === 'ArrowLeft' || key === 'a') keys.Left = state;
    if(key === 'ArrowRight' || key === 'd') keys.Right = state;
}

window.addEventListener('keydown', (e) => setKey(e.key, true));
window.addEventListener('keyup', (e) => setKey(e.key, false));

function bindTouch(id, keyName) {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[keyName] = true; });
    el.addEventListener('touchend', (e) => { e.preventDefault(); keys[keyName] = false; });
}
bindTouch('btnGas', 'Up');
bindTouch('btnBrake', 'Down');
bindTouch('btnLeft', 'Left');
bindTouch('btnRight', 'Right');

// Restart handler
window.addEventListener('touchstart', () => {
    if(!gameState.active) resetGame();
});
window.addEventListener('keydown', (e) => {
    if(!gameState.active && e.key === " ") resetGame();
});

// --- GAME OBJECTS ---
const gameState = { active: true };

const car = {
    x: 0, y: 0,
    w: 26, h: 48,
    angle: -Math.PI / 2,
    vx: 0, vy: 0,
    speed: 0,
    gear: 'P',
    // Physics
    maxSpeed: 28,
    accel: 0.3,
    friction: 0.97,
    turnSpeed: 0.05,
    grip: 0.93
};

let traffic = [];
let particles = [];
let skids = [];

function resetGame() {
    car.x = 0; // Center of road
    car.y = 0;
    car.vx = 0; car.vy = 0; 
    car.angle = -Math.PI / 2;
    traffic = [];
    skids = [];
    gameState.active = true;
    msgBox.style.display = 'none';
}

// --- PHYSICS ---
function updatePhysics() {
    if (!gameState.active) return;

    // 1. Throttle
    let thrust = 0;
    if (keys.Up) thrust = car.accel;
    if (keys.Down) thrust = -car.accel / 2;

    // 2. Steering & Wheel Visual
    let targetSteer = 0;
    if (keys.Left) targetSteer = -90;
    if (keys.Right) targetSteer = 90;
    
    // Smooth wheel rotation
    visualSteerAngle += (targetSteer - visualSteerAngle) * 0.2;
    wheelElement.style.transform = `rotate(${visualSteerAngle}deg)`;

    // Apply steering to car
    if (Math.abs(car.speed) > 0.5) {
        const dir = (keys.Down) ? -1 : 1;
        if (keys.Left) car.angle -= car.turnSpeed * dir;
        if (keys.Right) car.angle += car.turnSpeed * dir;
    }

    // 3. Move Car
    car.vx += Math.cos(car.angle) * thrust;
    car.vy += Math.sin(car.angle) * thrust;

    // Friction
    car.vx *= car.friction;
    car.vy *= car.friction;

    car.speed = Math.sqrt(car.vx**2 + car.vy**2);

    // Drift Logic
    if (car.speed > 0.1) {
        const hx = Math.cos(car.angle);
        const hy = Math.sin(car.angle);
        car.vx = car.vx * car.grip + (hx * car.speed) * (1 - car.grip);
        car.vy = car.vy * car.grip + (hy * car.speed) * (1 - car.grip);
    }

    car.x += car.vx;
    car.y += car.vy;

    // 4. Barrier Collision
    const roadEdge = ROAD_WIDTH / 2 - 20;
    if (car.x < -roadEdge || car.x > roadEdge) {
        if (car.speed > 8) {
            // Crash at high speed
            gameState.active = false;
            msgBox.style.display = 'block';
            createExplosion(car.x, car.y, '#333');
        } else {
            // Bounce at low speed
            car.x = (car.x < 0) ? -roadEdge : roadEdge;
            car.vx *= -0.5; // Bounce off wall
        }
    }

    // 5. Gearbox Logic
    const kph = Math.floor(car.speed * 8); // Fake KPH scale
    if(car.speed < 0.1 && !keys.Up && !keys.Down) car.gear = 'P';
    else if(keys.Down && car.speed > 0.5 && Math.abs(car.angle - Math.atan2(car.vy, car.vx)) < 1) car.gear = 'R'; // Crude reverse check
    else if(kph < 30) car.gear = '1';
    else if(kph < 70) car.gear = '2';
    else if(kph < 110) car.gear = '3';
    else car.gear = '4';

    uiSpeed.innerText = kph;
    uiGear.innerText = car.gear;

    // 6. Traffic Spawning
    manageTraffic();
    
    // 7. Skidmarks
    const moveAngle = Math.atan2(car.vy, car.vx);
    const drift = Math.abs(Math.sin(moveAngle - car.angle)) * car.speed;
    if (drift > 2) {
        const c = Math.cos(car.angle), s = Math.sin(car.angle);
        skids.push({x: car.x - c*20 - s*10, y: car.y - s*20 + c*10, a: 0.4});
        skids.push({x: car.x - c*20 + s*10, y: car.y - s*20 - c*10, a: 0.4});
    }
}

function manageTraffic() {
    // Spawn ahead
    if (traffic.length < 4 && car.speed > 2) {
        if (Math.random() < 0.03) {
            const lane = (Math.random() > 0.5) ? 1 : -1;
            const xPos = lane * (ROAD_WIDTH/4); // Two lanes
            const yPos = car.y + (Math.sin(car.angle) * 900) + (Math.random()*200);
            
            traffic.push({
                x: xPos, y: yPos,
                w: 26, h: 48,
                angle: car.angle, // Drive same direction
                speed: 8 + Math.random() * 6,
                color: ['#1e88e5', '#8e24aa', '#fdd835', '#43a047'][Math.floor(Math.random()*4)]
            });
        }
    }

    // Move & Collide
    for (let i = 0; i < traffic.length; i++) {
        let t = traffic[i];
        t.x += Math.cos(t.angle) * t.speed;
        t.y += Math.sin(t.angle) * t.speed;

        // Collision
        if (Math.hypot(car.x - t.x, car.y - t.y) < 30) {
            gameState.active = false;
            msgBox.style.display = 'block';
            createExplosion((car.x+t.x)/2, (car.y+t.y)/2, t.color);
        }

        // Cleanup
        if (Math.hypot(car.x - t.x, car.y - t.y) > 1200) {
            traffic.splice(i, 1);
            i--;
        }
    }
}

function createExplosion(x, y, color) {
    for(let k=0; k<25; k++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12,
            life: 60, color: color
        });
    }
}

// --- DRAWING ---
function draw() {
    // Canvas Background (Grass)
    ctx.fillStyle = '#4caf50';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    // Camera follow
    ctx.translate(canvas.width/2 - car.x, canvas.height/2 - car.y);

    // 1. Draw Road
    // We draw a long strip based on car Y to simulate infinity
    const drawDist = 1000;
    const roadTop = car.y - drawDist;
    const roadBot = car.y + drawDist;
    
    // Main Asphalt
    ctx.fillStyle = '#666'; 
    ctx.fillRect(-ROAD_WIDTH/2, roadTop, ROAD_WIDTH, (roadBot-roadTop));

    // Road Markings (Dashed Line)
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 4;
    ctx.setLineDash([30, 30]);
    ctx.beginPath();
    ctx.moveTo(0, roadTop);
    ctx.lineTo(0, roadBot);
    ctx.stroke();
    ctx.setLineDash([]);

    // Barriers (Red/White rails)
    const barrierSize = 40;
    const offset = Math.floor(car.y / barrierSize) * barrierSize; // Texture scrolling
    
    for(let y = roadTop - (roadTop%barrierSize); y < roadBot; y+=barrierSize) {
        // Left Barrier
        ctx.fillStyle = (Math.floor(y/barrierSize) % 2 === 0) ? '#d32f2f' : '#fff';
        ctx.fillRect(-ROAD_WIDTH/2 - 10, y, 10, barrierSize);
        // Right Barrier
        ctx.fillRect(ROAD_WIDTH/2, y, 10, barrierSize);
    }

    // 2. Skids
    for (let s of skids) {
        ctx.fillStyle = '#333';
        ctx.globalAlpha = s.a;
        ctx.fillRect(s.x, s.y, 4, 4);
        s.a -= 0.005;
        ctx.globalAlpha = 1;
    }

    // 3. Traffic
    for (let t of traffic) {
        drawVehicle(t.x, t.y, t.angle, t.color, false);
    }

    // 4. Player Car
    drawVehicle(car.x, car.y, car.angle, '#f57f17', true);

    // 5. Particles
    for (let i = 0; i < particles.length; i++) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.life--;
        ctx.fillStyle = p.color;
        ctx.beginPath(); 
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2); 
        ctx.fill();
        if(p.life<=0) { particles.splice(i,1); i--; }
    }

    ctx.restore();
    updatePhysics();
    requestAnimationFrame(draw);
}

function drawVehicle(x, y, angle, color, isPlayer) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(-22, -10, 48, 26);

    // Body
    ctx.fillStyle = color;
    // Drawing a simple sedan shape
    ctx.beginPath();
    ctx.roundRect(-24, -13, 48, 26, 4);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Roof / Windshield
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.roundRect(-10, -11, 24, 22, 3);
    ctx.fill();

    // Lights
    if(isPlayer && keys.Down) {
        ctx.fillStyle = '#ff0000'; // Braking
        ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10;
    } else {
        ctx.fillStyle = '#800000'; // Normal tail lights
        ctx.shadowBlur = 0;
    }
    // Tail lights
    ctx.fillRect(-24, -12, 2, 6);
    ctx.fillRect(-24, 6, 2, 6);
    ctx.shadowBlur = 0;

    // Headlights
    ctx.fillStyle = '#fff9c4';
    ctx.fillRect(22, -12, 2, 6);
    ctx.fillRect(22, 6, 2, 6);

    ctx.restore();
}

resetGame();
draw();
</script>
</body>
</html>
